<pre>
       Linux supports both POSIX reliable signals (hereinafter "standard
       signals") and POSIX real-time signals.

   <b>Signal dispositions</b>
       Each signal has a current <i>disposition</i>, which determines how the
       process behaves when it is delivered the signal.

       The entries in the "Action" column of the table below specify the
       default disposition for each signal, as follows:

       Term   Default action is to terminate the process.

       Ign    Default action is to ignore the signal.

       Core   Default action is to terminate the process and dump core
              (see <a href="https://man7.org/linux/man-pages/man5/core.5.html">core(5)</a>).

       Stop   Default action is to stop the process.

       Cont   Default action is to continue the process if it is
              currently stopped.

       A process can change the disposition of a signal using
       <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a> or <a href="https://man7.org/linux/man-pages/man2/signal.2.html">signal(2)</a>.  (The latter is less portable when
       establishing a signal handler; see <a href="https://man7.org/linux/man-pages/man2/signal.2.html">signal(2)</a> for details.)  Using
       these system calls, a process can elect one of the following
       behaviors to occur on delivery of the signal: perform the default
       action; ignore the signal; or catch the signal with a <i>signal</i>
       <i>handler</i>, a programmer-defined function that is automatically
       invoked when the signal is delivered.

       By default, a signal handler is invoked on the normal process
       stack.  It is possible to arrange that the signal handler uses an
       alternate stack; see <a href="https://man7.org/linux/man-pages/man2/sigaltstack.2.html">sigaltstack(2)</a> for a discussion of how to do
       this and when it might be useful.

       The signal disposition is a per-process attribute: in a
       multithreaded application, the disposition of a particular signal
       is the same for all threads.

       A child created via <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a> inherits a copy of its parent's
       signal dispositions.  During an <a href="https://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a>, the dispositions of
       handled signals are reset to the default; the dispositions of
       ignored signals are left unchanged.

   <b>Sending a signal</b>
       The following system calls and library functions allow the caller
       to send a signal:

       <a href="https://man7.org/linux/man-pages/man3/raise.3.html">raise(3)</a>
              Sends a signal to the calling thread.

       <a href="https://man7.org/linux/man-pages/man2/kill.2.html">kill(2)</a>
              Sends a signal to a specified process, to all members of a
              specified process group, or to all processes on the
              system.

       <a href="https://man7.org/linux/man-pages/man2/pidfd_send_signal.2.html">pidfd_send_signal(2)</a>
              Sends a signal to a process identified by a PID file
              descriptor.

       <a href="https://man7.org/linux/man-pages/man3/killpg.3.html">killpg(3)</a>
              Sends a signal to all of the members of a specified
              process group.

       <a href="https://man7.org/linux/man-pages/man3/pthread_kill.3.html">pthread_kill(3)</a>
              Sends a signal to a specified POSIX thread in the same
              process as the caller.

       <a href="https://man7.org/linux/man-pages/man2/tgkill.2.html">tgkill(2)</a>
              Sends a signal to a specified thread within a specific
              process.  (This is the system call used to implement
              <a href="https://man7.org/linux/man-pages/man3/pthread_kill.3.html">pthread_kill(3)</a>.)

       <a href="https://man7.org/linux/man-pages/man3/sigqueue.3.html">sigqueue(3)</a>
              Sends a real-time signal with accompanying data to a
              specified process.

   <b>Waiting for a signal to be caught</b>
       The following system calls suspend execution of the calling
       thread until a signal is caught (or an unhandled signal
       terminates the process):

       <a href="https://man7.org/linux/man-pages/man2/pause.2.html">pause(2)</a>
              Suspends execution until any signal is caught.

       <a href="https://man7.org/linux/man-pages/man2/sigsuspend.2.html">sigsuspend(2)</a>
              Temporarily changes the signal mask (see below) and
              suspends execution until one of the unmasked signals is
              caught.

   <b>Synchronously accepting a signal</b>
       Rather than asynchronously catching a signal via a signal
       handler, it is possible to synchronously accept the signal, that
       is, to block execution until the signal is delivered, at which
       point the kernel returns information about the signal to the
       caller.  There are two general ways to do this:

       * <a href="https://man7.org/linux/man-pages/man2/sigwaitinfo.2.html">sigwaitinfo(2)</a>, <a href="https://man7.org/linux/man-pages/man2/sigtimedwait.2.html">sigtimedwait(2)</a>, and <a href="https://man7.org/linux/man-pages/man3/sigwait.3.html">sigwait(3)</a> suspend
         execution until one of the signals in a specified set is
         delivered.  Each of these calls returns information about the
         delivered signal.

       * <a href="https://man7.org/linux/man-pages/man2/signalfd.2.html">signalfd(2)</a> returns a file descriptor that can be used to read
         information about signals that are delivered to the caller.
         Each <a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a> from this file descriptor blocks until one of the
         signals in the set specified in the <a href="https://man7.org/linux/man-pages/man2/signalfd.2.html">signalfd(2)</a> call is
         delivered to the caller.  The buffer returned by <a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>
         contains a structure describing the signal.

   <b>Signal mask and pending signals</b>
       A signal may be <i>blocked</i>, which means that it will not be
       delivered until it is later unblocked.  Between the time when it
       is generated and when it is delivered a signal is said to be
       <i>pending</i>.

       Each thread in a process has an independent <i>signal mask</i>, which
       indicates the set of signals that the thread is currently
       blocking.  A thread can manipulate its signal mask using
       <a href="https://man7.org/linux/man-pages/man3/pthread_sigmask.3.html">pthread_sigmask(3)</a>.  In a traditional single-threaded
       application, <a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html">sigprocmask(2)</a> can be used to manipulate the signal
       mask.

       A child created via <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a> inherits a copy of its parent's
       signal mask; the signal mask is preserved across <a href="https://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a>.

       A signal may be process-directed or thread-directed.  A process-
       directed signal is one that is targeted at (and thus pending for)
       the process as a whole.  A signal may be process-directed because
       it was generated by the kernel for reasons other than a hardware
       exception, or because it was sent using <a href="https://man7.org/linux/man-pages/man2/kill.2.html">kill(2)</a> or <a href="https://man7.org/linux/man-pages/man3/sigqueue.3.html">sigqueue(3)</a>.
       A thread-directed signal is one that is targeted at a specific
       thread.  A signal may be thread-directed because it was generated
       as a consequence of executing a specific machine-language
       instruction that triggered a hardware exception (e.g., <b>SIGSEGV</b>
       for an invalid memory access, or <b>SIGFPE </b>for a math error), or
       because it was targeted at a specific thread using interfaces
       such as <a href="https://man7.org/linux/man-pages/man2/tgkill.2.html">tgkill(2)</a> or <a href="https://man7.org/linux/man-pages/man3/pthread_kill.3.html">pthread_kill(3)</a>.

       A process-directed signal may be delivered to any one of the
       threads that does not currently have the signal blocked.  If more
       than one of the threads has the signal unblocked, then the kernel
       chooses an arbitrary thread to which to deliver the signal.

       A thread can obtain the set of signals that it currently has
       pending using <a href="https://man7.org/linux/man-pages/man2/sigpending.2.html">sigpending(2)</a>.  This set will consist of the union
       of the set of pending process-directed signals and the set of
       signals pending for the calling thread.

       A child created via <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a> initially has an empty pending signal
       set; the pending signal set is preserved across an <a href="https://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a>.

   <b>Execution of signal handlers</b>
       Whenever there is a transition from kernel-mode to user-mode
       execution (e.g., on return from a system call or scheduling of a
       thread onto the CPU), the kernel checks whether there is a
       pending unblocked signal for which the process has established a
       signal handler.  If there is such a pending signal, the following
       steps occur:

       1. The kernel performs the necessary preparatory steps for
          execution of the signal handler:

          a) The signal is removed from the set of pending signals.

          b) If the signal handler was installed by a call to
             <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a> that specified the <b>SA_ONSTACK </b>flag and the
             thread has defined an alternate signal stack (using
             <a href="https://man7.org/linux/man-pages/man2/sigaltstack.2.html">sigaltstack(2)</a>), then that stack is installed.

          c) Various pieces of signal-related context are saved into a
             special frame that is created on the stack.  The saved
             information includes:

             + the program counter register (i.e., the address of the
               next instruction in the main program that should be
               executed when the signal handler returns);

             + architecture-specific register state required for
               resuming the interrupted program;

             + the thread's current signal mask;

             + the thread's alternate signal stack settings.

             (If the signal handler was installed using the <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a>
             <b>SA_SIGINFO </b>flag, then the above information is accessible
             via the <i>ucontext_t</i> object that is pointed to by the third
             argument of the signal handler.)

          d) Any signals specified in <i>act-&gt;sa_mask</i> when registering the
             handler with <a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html">sigprocmask(2)</a> are added to the thread's
             signal mask.  The signal being delivered is also added to
             the signal mask, unless <b>SA_NODEFER </b>was specified when
             registering the handler.  These signals are thus blocked
             while the handler executes.

       2. The kernel constructs a frame for the signal handler on the
          stack.  The kernel sets the program counter for the thread to
          point to the first instruction of the signal handler function,
          and configures the return address for that function to point
          to a piece of user-space code known as the signal trampoline
          (described in <a href="https://man7.org/linux/man-pages/man2/sigreturn.2.html">sigreturn(2)</a>).

       3. The kernel passes control back to user-space, where execution
          commences at the start of the signal handler function.

       4. When the signal handler returns, control passes to the signal
          trampoline code.

       5. The signal trampoline calls <a href="https://man7.org/linux/man-pages/man2/sigreturn.2.html">sigreturn(2)</a>, a system call that
          uses the information in the stack frame created in step 1 to
          restore the thread to its state before the signal handler was
          called.  The thread's signal mask and alternate signal stack
          settings are restored as part of this procedure.  Upon
          completion of the call to <a href="https://man7.org/linux/man-pages/man2/sigreturn.2.html">sigreturn(2)</a>, the kernel transfers
          control back to user space, and the thread recommences
          execution at the point where it was interrupted by the signal
          handler.

       Note that if the signal handler does not return (e.g., control is
       transferred out of the handler using <a href="https://man7.org/linux/man-pages/man3/siglongjmp.3.html">siglongjmp(3)</a>, or the
       handler executes a new program with <a href="https://man7.org/linux/man-pages/man2/execve.2.html">execve(2)</a>), then the final
       step is not performed.  In particular, in such scenarios it is
       the programmer's responsibility to restore the state of the
       signal mask (using <a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html">sigprocmask(2)</a>), if it is desired to unblock
       the signals that were blocked on entry to the signal handler.
       (Note that <a href="https://man7.org/linux/man-pages/man3/siglongjmp.3.html">siglongjmp(3)</a> may or may not restore the signal mask,
       depending on the <i>savesigs</i> value that was specified in the
       corresponding call to <a href="https://man7.org/linux/man-pages/man3/sigsetjmp.3.html">sigsetjmp(3)</a>.)

       From the kernel's point of view, execution of the signal handler
       code is exactly the same as the execution of any other user-space
       code.  That is to say, the kernel does not record any special
       state information indicating that the thread is currently
       executing inside a signal handler.  All necessary state
       information is maintained in user-space registers and the user-
       space stack.  The depth to which nested signal handlers may be
       invoked is thus limited only by the user-space stack (and
       sensible software design!).

   <b>Standard signals</b>
       Linux supports the standard signals listed below.  The second
       column of the table indicates which standard (if any) specified
       the signal: "P1990" indicates that the signal is described in the
       original POSIX.1-1990 standard; "P2001" indicates that the signal
       was added in SUSv2 and POSIX.1-2001.

       Signal      Standard   Action   Comment
       ────────────────────────────────────────────────────────────────────────
       <b>SIGABRT      </b>P1990      Core    Abort signal from <a href="https://man7.org/linux/man-pages/man3/abort.3.html">abort(3)</a>
       <b>SIGALRM      </b>P1990      Term    Timer signal from <a href="https://man7.org/linux/man-pages/man2/alarm.2.html">alarm(2)</a>
       <b>SIGBUS       </b>P2001      Core    Bus error (bad memory access)
       <b>SIGCHLD      </b>P1990      Ign     Child stopped or terminated
       <b>SIGCLD         </b>-        Ign     A synonym for <b>SIGCHLD</b>
       <b>SIGCONT      </b>P1990      Cont    Continue if stopped
       <b>SIGEMT         </b>-        Term    Emulator trap
       <b>SIGFPE       </b>P1990      Core    Floating-point exception
       <b>SIGHUP       </b>P1990      Term    Hangup detected on controlling terminal
                                       or death of controlling process
       <b>SIGILL       </b>P1990      Core    Illegal Instruction
       <b>SIGINFO        </b>-                A synonym for <b>SIGPWR</b>
       <b>SIGINT       </b>P1990      Term    Interrupt from keyboard

       <b>SIGIO          </b>-        Term    I/O now possible (4.2BSD)
       <b>SIGIOT         </b>-        Core    IOT trap. A synonym for <b>SIGABRT</b>
       <b>SIGKILL      </b>P1990      Term    Kill signal
       <b>SIGLOST        </b>-        Term    File lock lost (unused)
       <b>SIGPIPE      </b>P1990      Term    Broken pipe: write to pipe with no
                                       readers; see <a href="https://man7.org/linux/man-pages/man7/pipe.7.html">pipe(7)</a>
       <b>SIGPOLL      </b>P2001      Term    Pollable event (Sys V);
                                       synonym for <b>SIGIO</b>
       <b>SIGPROF      </b>P2001      Term    Profiling timer expired
       <b>SIGPWR         </b>-        Term    Power failure (System V)
       <b>SIGQUIT      </b>P1990      Core    Quit from keyboard
       <b>SIGSEGV      </b>P1990      Core    Invalid memory reference
       <b>SIGSTKFLT      </b>-        Term    Stack fault on coprocessor (unused)
       <b>SIGSTOP      </b>P1990      Stop    Stop process
       <b>SIGTSTP      </b>P1990      Stop    Stop typed at terminal
       <b>SIGSYS       </b>P2001      Core    Bad system call (SVr4);
                                       see also <a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp(2)</a>
       <b>SIGTERM      </b>P1990      Term    Termination signal
       <b>SIGTRAP      </b>P2001      Core    Trace/breakpoint trap
       <b>SIGTTIN      </b>P1990      Stop    Terminal input for background process
       <b>SIGTTOU      </b>P1990      Stop    Terminal output for background process
       <b>SIGUNUSED      </b>-        Core    Synonymous with <b>SIGSYS</b>
       <b>SIGURG       </b>P2001      Ign     Urgent condition on socket (4.2BSD)
       <b>SIGUSR1      </b>P1990      Term    User-defined signal 1
       <b>SIGUSR2      </b>P1990      Term    User-defined signal 2
       <b>SIGVTALRM    </b>P2001      Term    Virtual alarm clock (4.2BSD)
       <b>SIGXCPU      </b>P2001      Core    CPU time limit exceeded (4.2BSD);
                                       see <a href="https://man7.org/linux/man-pages/man2/setrlimit.2.html">setrlimit(2)</a>
       <b>SIGXFSZ      </b>P2001      Core    File size limit exceeded (4.2BSD);
                                       see <a href="https://man7.org/linux/man-pages/man2/setrlimit.2.html">setrlimit(2)</a>
       <b>SIGWINCH       </b>-        Ign     Window resize signal (4.3BSD, Sun)

       The signals <b>SIGKILL </b>and <b>SIGSTOP </b>cannot be caught, blocked, or
       ignored.

       Up to and including Linux 2.2, the default behavior for <b>SIGSYS</b>,
       <b>SIGXCPU</b>, <b>SIGXFSZ</b>, and (on architectures other than SPARC and
       MIPS) <b>SIGBUS </b>was to terminate the process (without a core dump).
       (On some other UNIX systems the default action for <b>SIGXCPU </b>and
       <b>SIGXFSZ </b>is to terminate the process without a core dump.)  Linux
       2.4 conforms to the POSIX.1-2001 requirements for these signals,
       terminating the process with a core dump.

       <b>SIGEMT </b>is not specified in POSIX.1-2001, but nevertheless appears
       on most other UNIX systems, where its default action is typically
       to terminate the process with a core dump.

       <b>SIGPWR </b>(which is not specified in POSIX.1-2001) is typically
       ignored by default on those other UNIX systems where it appears.

       <b>SIGIO </b>(which is not specified in POSIX.1-2001) is ignored by
       default on several other UNIX systems.

   <b>Queueing and delivery semantics for standard signals</b>
       If multiple standard signals are pending for a process, the order
       in which the signals are delivered is unspecified.

       Standard signals do not queue.  If multiple instances of a
       standard signal are generated while that signal is blocked, then
       only one instance of the signal is marked as pending (and the
       signal will be delivered just once when it is unblocked).  In the
       case where a standard signal is already pending, the <i>siginfo_t</i>
       structure (see <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a>) associated with that signal is not
       overwritten on arrival of subsequent instances of the same
       signal.  Thus, the process will receive the information
       associated with the first instance of the signal.

   <b>Signal numbering for standard signals</b>
       The numeric value for each signal is given in the table below.
       As shown in the table, many signals have different numeric values
       on different architectures.  The first numeric value in each
       table row shows the signal number on x86, ARM, and most other
       architectures; the second value is for Alpha and SPARC; the third
       is for MIPS; and the last is for PARISC.  A dash (-) denotes that
       a signal is absent on the corresponding architecture.

       Signal        x86/ARM     Alpha/   MIPS   PARISC   Notes
                   most others   SPARC
       ─────────────────────────────────────────────────────────────────
       <b>SIGHUP           </b>1           1       1       1
       <b>SIGINT           </b>2           2       2       2
       <b>SIGQUIT          </b>3           3       3       3
       <b>SIGILL           </b>4           4       4       4
       <b>SIGTRAP          </b>5           5       5       5
       <b>SIGABRT          </b>6           6       6       6
       <b>SIGIOT           </b>6           6       6       6
       <b>SIGBUS           </b>7          10      10      10
       <b>SIGEMT           </b>-           7       7      -
       <b>SIGFPE           </b>8           8       8       8
       <b>SIGKILL          </b>9           9       9       9
       <b>SIGUSR1         </b>10          30      16      16
       <b>SIGSEGV         </b>11          11      11      11
       <b>SIGUSR2         </b>12          31      17      17
       <b>SIGPIPE         </b>13          13      13      13
       <b>SIGALRM         </b>14          14      14      14
       <b>SIGTERM         </b>15          15      15      15
       <b>SIGSTKFLT       </b>16          -       -        7
       <b>SIGCHLD         </b>17          20      18      18
       <b>SIGCLD           </b>-          -       18      -
       <b>SIGCONT         </b>18          19      25      26
       <b>SIGSTOP         </b>19          17      23      24
       <b>SIGTSTP         </b>20          18      24      25
       <b>SIGTTIN         </b>21          21      26      27
       <b>SIGTTOU         </b>22          22      27      28
       <b>SIGURG          </b>23          16      21      29
       <b>SIGXCPU         </b>24          24      30      12
       <b>SIGXFSZ         </b>25          25      31      30
       <b>SIGVTALRM       </b>26          26      28      20
       <b>SIGPROF         </b>27          27      29      21
       <b>SIGWINCH        </b>28          28      20      23
       <b>SIGIO           </b>29          23      22      22
       <b>SIGPOLL                                            </b>Same as SIGIO
       <b>SIGPWR          </b>30         29/-     19      19
       <b>SIGINFO          </b>-         29/-     -       -
       <b>SIGLOST          </b>-         -/29     -       -
       <b>SIGSYS          </b>31          12      12      31
       <b>SIGUNUSED       </b>31          -       -       31

       Note the following:

       *  Where defined, <b>SIGUNUSED </b>is synonymous with <b>SIGSYS</b>.  Since
          glibc 2.26, <b>SIGUNUSED </b>is no longer defined on any
          architecture.

       *  Signal 29 is <b>SIGINFO</b>/<b>SIGPWR </b>(synonyms for the same value) on
          Alpha but <b>SIGLOST </b>on SPARC.

   <b>Real-time signals</b>
       Starting with version 2.2, Linux supports real-time signals as
       originally defined in the POSIX.1b real-time extensions (and now
       included in POSIX.1-2001).  The range of supported real-time
       signals is defined by the macros <b>SIGRTMIN </b>and <b>SIGRTMAX</b>.
       POSIX.1-2001 requires that an implementation support at least
       <b>_POSIX_RTSIG_MAX </b>(8) real-time signals.

       The Linux kernel supports a range of 33 different real-time
       signals, numbered 32 to 64.  However, the glibc POSIX threads
       implementation internally uses two (for NPTL) or three (for
       LinuxThreads) real-time signals (see <a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">pthreads(7)</a>), and adjusts
       the value of <b>SIGRTMIN </b>suitably (to 34 or 35).  Because the range
       of available real-time signals varies according to the glibc
       threading implementation (and this variation can occur at run
       time according to the available kernel and glibc), and indeed the
       range of real-time signals varies across UNIX systems, programs
       should <i>never refer to real-time signals using hard-coded numbers</i>,
       but instead should always refer to real-time signals using the
       notation <b>SIGRTMIN</b>+n, and include suitable (run-time) checks that
       <b>SIGRTMIN</b>+n does not exceed <b>SIGRTMAX</b>.

       Unlike standard signals, real-time signals have no predefined
       meanings: the entire set of real-time signals can be used for
       application-defined purposes.

       The default action for an unhandled real-time signal is to
       terminate the receiving process.

       Real-time signals are distinguished by the following:

       1.  Multiple instances of real-time signals can be queued.  By
           contrast, if multiple instances of a standard signal are
           delivered while that signal is currently blocked, then only
           one instance is queued.

       2.  If the signal is sent using <a href="https://man7.org/linux/man-pages/man3/sigqueue.3.html">sigqueue(3)</a>, an accompanying
           value (either an integer or a pointer) can be sent with the
           signal.  If the receiving process establishes a handler for
           this signal using the <b>SA_SIGINFO </b>flag to <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a>, then
           it can obtain this data via the <i>si_value</i> field of the
           <i>siginfo_t</i> structure passed as the second argument to the
           handler.  Furthermore, the <i>si_pid</i> and <i>si_uid</i> fields of this
           structure can be used to obtain the PID and real user ID of
           the process sending the signal.

       3.  Real-time signals are delivered in a guaranteed order.
           Multiple real-time signals of the same type are delivered in
           the order they were sent.  If different real-time signals are
           sent to a process, they are delivered starting with the
           lowest-numbered signal.  (I.e., low-numbered signals have
           highest priority.)  By contrast, if multiple standard signals
           are pending for a process, the order in which they are
           delivered is unspecified.

       If both standard and real-time signals are pending for a process,
       POSIX leaves it unspecified which is delivered first.  Linux,
       like many other implementations, gives priority to standard
       signals in this case.

       According to POSIX, an implementation should permit at least
       <b>_POSIX_SIGQUEUE_MAX </b>(32) real-time signals to be queued to a
       process.  However, Linux does things differently.  In kernels up
       to and including 2.6.7, Linux imposes a system-wide limit on the
       number of queued real-time signals for all processes.  This limit
       can be viewed and (with privilege) changed via the
       <i>/proc/sys/kernel/rtsig-max</i> file.  A related file,
       <i>/proc/sys/kernel/rtsig-nr</i>, can be used to find out how many real-
       time signals are currently queued.  In Linux 2.6.8, these <i>/proc</i>
       interfaces were replaced by the <b>RLIMIT_SIGPENDING </b>resource limit,
       which specifies a per-user limit for queued signals; see
       <a href="https://man7.org/linux/man-pages/man2/setrlimit.2.html">setrlimit(2)</a> for further details.

       The addition of real-time signals required the widening of the
       signal set structure (<i>sigset_t</i>) from 32 to 64 bits.
       Consequently, various system calls were superseded by new system
       calls that supported the larger signal sets.  The old and new
       system calls are as follows:

       <b>Linux 2.0 and earlier   Linux 2.2 and later</b>
       <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a>            <a href="https://man7.org/linux/man-pages/man2/rt_sigaction.2.html">rt_sigaction(2)</a>
       <a href="https://man7.org/linux/man-pages/man2/sigpending.2.html">sigpending(2)</a>           <a href="https://man7.org/linux/man-pages/man2/rt_sigpending.2.html">rt_sigpending(2)</a>

       <a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html">sigprocmask(2)</a>          <a href="https://man7.org/linux/man-pages/man2/rt_sigprocmask.2.html">rt_sigprocmask(2)</a>
       <a href="https://man7.org/linux/man-pages/man2/sigreturn.2.html">sigreturn(2)</a>            <a href="https://man7.org/linux/man-pages/man2/rt_sigreturn.2.html">rt_sigreturn(2)</a>
       <a href="https://man7.org/linux/man-pages/man2/sigsuspend.2.html">sigsuspend(2)</a>           <a href="https://man7.org/linux/man-pages/man2/rt_sigsuspend.2.html">rt_sigsuspend(2)</a>
       <a href="https://man7.org/linux/man-pages/man2/sigtimedwait.2.html">sigtimedwait(2)</a>         <a href="https://man7.org/linux/man-pages/man2/rt_sigtimedwait.2.html">rt_sigtimedwait(2)</a>

   <b>Interruption of system calls and library functions by signal handlers</b>
       If a signal handler is invoked while a system call or library
       function call is blocked, then either:

       * the call is automatically restarted after the signal handler
         returns; or

       * the call fails with the error <b>EINTR</b>.

       Which of these two behaviors occurs depends on the interface and
       whether or not the signal handler was established using the
       <b>SA_RESTART </b>flag (see <a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a>).  The details vary across UNIX
       systems; below, the details for Linux.

       If a blocked call to one of the following interfaces is
       interrupted by a signal handler, then the call is automatically
       restarted after the signal handler returns if the <b>SA_RESTART </b>flag
       was used; otherwise the call fails with the error <b>EINTR</b>:

       * <a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>, <a href="https://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write(2)</a>, <a href="https://man7.org/linux/man-pages/man2/writev.2.html">writev(2)</a>, and <a href="https://man7.org/linux/man-pages/man2/ioctl.2.html">ioctl(2)</a> calls on
         "slow" devices.  A "slow" device is one where the I/O call may
         block for an indefinite time, for example, a terminal, pipe, or
         socket.  If an I/O call on a slow device has already
         transferred some data by the time it is interrupted by a signal
         handler, then the call will return a success status (normally,
         the number of bytes transferred).  Note that a (local) disk is
         not a slow device according to this definition; I/O operations
         on disk devices are not interrupted by signals.

       * <a href="https://man7.org/linux/man-pages/man2/open.2.html">open(2)</a>, if it can block (e.g., when opening a FIFO; see
         <a href="https://man7.org/linux/man-pages/man7/fifo.7.html">fifo(7)</a>).

       * <a href="https://man7.org/linux/man-pages/man2/wait.2.html">wait(2)</a>, <a href="https://man7.org/linux/man-pages/man2/wait3.2.html">wait3(2)</a>, <a href="https://man7.org/linux/man-pages/man2/wait4.2.html">wait4(2)</a>, <a href="https://man7.org/linux/man-pages/man2/waitid.2.html">waitid(2)</a>, and <a href="https://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid(2)</a>.

       * Socket interfaces: <a href="https://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>, <a href="https://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>, <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>, <a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom(2)</a>,
         <a href="https://man7.org/linux/man-pages/man2/recvmmsg.2.html">recvmmsg(2)</a>, <a href="https://man7.org/linux/man-pages/man2/recvmsg.2.html">recvmsg(2)</a>, <a href="https://man7.org/linux/man-pages/man2/send.2.html">send(2)</a>, <a href="https://man7.org/linux/man-pages/man2/sendto.2.html">sendto(2)</a>, and <a href="https://man7.org/linux/man-pages/man2/sendmsg.2.html">sendmsg(2)</a>,
         unless a timeout has been set on the socket (see below).

       * File locking interfaces: <a href="https://man7.org/linux/man-pages/man2/flock.2.html">flock(2)</a> and the <b>F_SETLKW </b>and
         <b>F_OFD_SETLKW </b>operations of <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl(2)</a>

       * POSIX message queue interfaces: <a href="https://man7.org/linux/man-pages/man3/mq_receive.3.html">mq_receive(3)</a>,
         <a href="https://man7.org/linux/man-pages/man3/mq_timedreceive.3.html">mq_timedreceive(3)</a>, <a href="https://man7.org/linux/man-pages/man3/mq_send.3.html">mq_send(3)</a>, and <a href="https://man7.org/linux/man-pages/man3/mq_timedsend.3.html">mq_timedsend(3)</a>.

       * <a href="https://man7.org/linux/man-pages/man2/futex.2.html">futex(2)</a> <b>FUTEX_WAIT </b>(since Linux 2.6.22; beforehand, always
         failed with <b>EINTR</b>).

       * <a href="https://man7.org/linux/man-pages/man2/getrandom.2.html">getrandom(2)</a>.

       * <b>pthread_mutex_lock</b>(3), <b>pthread_cond_wait</b>(3), and related APIs.

       * <a href="https://man7.org/linux/man-pages/man2/futex.2.html">futex(2)</a> <b>FUTEX_WAIT_BITSET</b>.

       * POSIX semaphore interfaces: <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait(3)</a> and <a href="https://man7.org/linux/man-pages/man3/sem_timedwait.3.html">sem_timedwait(3)</a>
         (since Linux 2.6.22; beforehand, always failed with <b>EINTR</b>).

       * <a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a> from an <a href="https://man7.org/linux/man-pages/man7/inotify.7.html">inotify(7)</a> file descriptor (since Linux 3.8;
         beforehand, always failed with <b>EINTR</b>).

       The following interfaces are never restarted after being
       interrupted by a signal handler, regardless of the use of
       <b>SA_RESTART</b>; they always fail with the error <b>EINTR </b>when
       interrupted by a signal handler:

       * "Input" socket interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has
         been set on the socket using <a href="https://man7.org/linux/man-pages/man2/setsockopt.2.html">setsockopt(2)</a>: <a href="https://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>, <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>,
         <a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom(2)</a>, <a href="https://man7.org/linux/man-pages/man2/recvmmsg.2.html">recvmmsg(2)</a> (also with a non-NULL <i>timeout</i>
         argument), and <a href="https://man7.org/linux/man-pages/man2/recvmsg.2.html">recvmsg(2)</a>.

       * "Output" socket interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has
         been set on the socket using <a href="https://man7.org/linux/man-pages/man2/setsockopt.2.html">setsockopt(2)</a>: <a href="https://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>,
         <a href="https://man7.org/linux/man-pages/man2/send.2.html">send(2)</a>, <a href="https://man7.org/linux/man-pages/man2/sendto.2.html">sendto(2)</a>, and <a href="https://man7.org/linux/man-pages/man2/sendmsg.2.html">sendmsg(2)</a>.

       * Interfaces used to wait for signals: <a href="https://man7.org/linux/man-pages/man2/pause.2.html">pause(2)</a>, <a href="https://man7.org/linux/man-pages/man2/sigsuspend.2.html">sigsuspend(2)</a>,
         <a href="https://man7.org/linux/man-pages/man2/sigtimedwait.2.html">sigtimedwait(2)</a>, and <a href="https://man7.org/linux/man-pages/man2/sigwaitinfo.2.html">sigwaitinfo(2)</a>.

       * File descriptor multiplexing interfaces: <a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html">epoll_wait(2)</a>,
         <a href="https://man7.org/linux/man-pages/man2/epoll_pwait.2.html">epoll_pwait(2)</a>, <a href="https://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</a>, <a href="https://man7.org/linux/man-pages/man2/ppoll.2.html">ppoll(2)</a>, <a href="https://man7.org/linux/man-pages/man2/select.2.html">select(2)</a>, and <a href="https://man7.org/linux/man-pages/man2/pselect.2.html">pselect(2)</a>.

       * System V IPC interfaces: <a href="https://man7.org/linux/man-pages/man2/msgrcv.2.html">msgrcv(2)</a>, <a href="https://man7.org/linux/man-pages/man2/msgsnd.2.html">msgsnd(2)</a>, <a href="https://man7.org/linux/man-pages/man2/semop.2.html">semop(2)</a>, and
         <a href="https://man7.org/linux/man-pages/man2/semtimedop.2.html">semtimedop(2)</a>.

       * Sleep interfaces: <a href="https://man7.org/linux/man-pages/man2/clock_nanosleep.2.html">clock_nanosleep(2)</a>, <a href="https://man7.org/linux/man-pages/man2/nanosleep.2.html">nanosleep(2)</a>, and
         <a href="https://man7.org/linux/man-pages/man3/usleep.3.html">usleep(3)</a>.

       * <a href="https://man7.org/linux/man-pages/man2/io_getevents.2.html">io_getevents(2)</a>.

       The <a href="https://man7.org/linux/man-pages/man3/sleep.3.html">sleep(3)</a> function is also never restarted if interrupted by a
       handler, but gives a success return: the number of seconds
       remaining to sleep.

       In certain circumstances, the <a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">seccomp(2)</a> user-space notification
       feature can lead to restarting of system calls that would
       otherwise never be restarted by <b>SA_RESTART</b>; for details, see
       <a href="https://man7.org/linux/man-pages/man2/seccomp_unotify.2.html">seccomp_unotify(2)</a>.

   <b>Interruption of system calls and library functions by stop signals</b>
       On Linux, even in the absence of signal handlers, certain
       blocking interfaces can fail with the error <b>EINTR </b>after the
       process is stopped by one of the stop signals and then resumed
       via <b>SIGCONT</b>.  This behavior is not sanctioned by POSIX.1, and
       doesn't occur on other systems.

       The Linux interfaces that display this behavior are:

       * "Input" socket interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has
         been set on the socket using <a href="https://man7.org/linux/man-pages/man2/setsockopt.2.html">setsockopt(2)</a>: <a href="https://man7.org/linux/man-pages/man2/accept.2.html">accept(2)</a>, <a href="https://man7.org/linux/man-pages/man2/recv.2.html">recv(2)</a>,
         <a href="https://man7.org/linux/man-pages/man2/recvfrom.2.html">recvfrom(2)</a>, <a href="https://man7.org/linux/man-pages/man2/recvmmsg.2.html">recvmmsg(2)</a> (also with a non-NULL <i>timeout</i>
         argument), and <a href="https://man7.org/linux/man-pages/man2/recvmsg.2.html">recvmsg(2)</a>.

       * "Output" socket interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has
         been set on the socket using <a href="https://man7.org/linux/man-pages/man2/setsockopt.2.html">setsockopt(2)</a>: <a href="https://man7.org/linux/man-pages/man2/connect.2.html">connect(2)</a>,
         <a href="https://man7.org/linux/man-pages/man2/send.2.html">send(2)</a>, <a href="https://man7.org/linux/man-pages/man2/sendto.2.html">sendto(2)</a>, and <a href="https://man7.org/linux/man-pages/man2/sendmsg.2.html">sendmsg(2)</a>, if a send timeout
         (<b>SO_SNDTIMEO</b>) has been set.

       * <a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html">epoll_wait(2)</a>, <a href="https://man7.org/linux/man-pages/man2/epoll_pwait.2.html">epoll_pwait(2)</a>.

       * <a href="https://man7.org/linux/man-pages/man2/semop.2.html">semop(2)</a>, <a href="https://man7.org/linux/man-pages/man2/semtimedop.2.html">semtimedop(2)</a>.

       * <a href="https://man7.org/linux/man-pages/man2/sigtimedwait.2.html">sigtimedwait(2)</a>, <a href="https://man7.org/linux/man-pages/man2/sigwaitinfo.2.html">sigwaitinfo(2)</a>.

       * Linux 3.7 and earlier: <a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a> from an <a href="https://man7.org/linux/man-pages/man7/inotify.7.html">inotify(7)</a> file
         descriptor

       * Linux 2.6.21 and earlier: <a href="https://man7.org/linux/man-pages/man2/futex.2.html">futex(2)</a> <b>FUTEX_WAIT</b>,
         <a href="https://man7.org/linux/man-pages/man3/sem_timedwait.3.html">sem_timedwait(3)</a>, <a href="https://man7.org/linux/man-pages/man3/sem_wait.3.html">sem_wait(3)</a>.

       * Linux 2.6.8 and earlier: <a href="https://man7.org/linux/man-pages/man2/msgrcv.2.html">msgrcv(2)</a>, <a href="https://man7.org/linux/man-pages/man2/msgsnd.2.html">msgsnd(2)</a>.

       * Linux 2.4 and earlier: <a href="https://man7.org/linux/man-pages/man2/nanosleep.2.html">nanosleep(2)</a>.
</pre>