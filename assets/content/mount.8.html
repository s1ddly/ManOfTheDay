<pre>
       All files accessible in a Unix system are arranged in one big
       tree, the file hierarchy, rooted at <i>/</i>. These files can be spread
       out over several devices. The <b>mount </b>command serves to attach the
       filesystem found on some device to the big file tree. Conversely,
       the <a href="https://man7.org/linux/man-pages/man8/umount.8.html">umount(8)</a> command will detach it again. The filesystem is
       used to control how data is stored on the device or provided in a
       virtual way by network or other services.

       The standard form of the <b>mount </b>command is:

          <b>mount -t </b><i>type device dir</i>

       This tells the kernel to attach the filesystem found on <i>device</i>
       (which is of type <i>type</i>) at the directory <i>dir</i>. The option <b>-t </b><i>type</i>
       is optional. The <b>mount </b>command is usually able to detect a
       filesystem. The root permissions are necessary to mount a
       filesystem by default. See section "Non-superuser mounts" below
       for more details. The previous contents (if any) and owner and
       mode of <i>dir</i> become invisible, and as long as this filesystem
       remains mounted, the pathname <i>dir</i> refers to the root of the
       filesystem on <i>device</i>.

       If only the directory or the device is given, for example:

          <b>mount /dir</b>

       then <b>mount </b>looks for a mountpoint (and if not found then for a
       device) in the <i>/etc/fstab</i> file. It’s possible to use the <b>--target</b>
       or <b>--source </b>options to avoid ambiguous interpretation of the
       given argument. For example:

          <b>mount --target /mountpoint</b>

       The same filesystem may be mounted more than once, and in some
       cases (e.g., network filesystems) the same filesystem may be
       mounted on the same mountpoint multiple times. The <b>mount </b>command
       does not implement any policy to control this behavior. All
       behavior is controlled by the kernel and it is usually specific
       to the filesystem driver. The exception is <b>--all</b>, in this case
       already mounted filesystems are ignored (see <b>--all </b>below for more
       details).

   <b>Listing the mounts</b>
       The listing mode is maintained for backward compatibility only.

       For more robust and customizable output use <a href="https://man7.org/linux/man-pages/man8/findmnt.8.html">findmnt(8)</a>,
       <b>especially in your scripts</b>. Note that control characters in the
       mountpoint name are replaced with '?'.

       The following command lists all mounted filesystems (of type
       <i>type</i>):

          <b>mount </b>[<b>-l</b>] [<b>-t </b><i>type</i>]

       The option <b>-l </b>adds labels to this listing. See below.

   <b>Indicating the device and filesystem</b>
       Most devices are indicated by a filename (of a block special
       device), like <i>/dev/sda1</i>, but there are other possibilities. For
       example, in the case of an NFS mount, <i>device</i> may look like
       <i>knuth.cwi.nl:/dir</i>.

       The device names of disk partitions are unstable; hardware
       reconfiguration, and adding or removing a device can cause
       changes in names. This is the reason why it’s strongly
       recommended to use filesystem or partition identifiers like UUID
       or LABEL. Currently supported identifiers (tags):

       LABEL=<i>label</i>
           Human readable filesystem identifier. See also <b>-L</b>.

       UUID=<i>uuid</i>
           Filesystem universally unique identifier. The format of the
           UUID is usually a series of hex digits separated by hyphens.
           See also <b>-U</b>.

           Note that <b>mount </b>uses UUIDs as strings. The UUIDs from the
           command line or from <a href="https://man7.org/linux/man-pages/man5/fstab.5.html">fstab(5)</a> are not converted to internal
           binary representation. The string representation of the UUID
           should be based on lower case characters.

       PARTLABEL=<i>label</i>
           Human readable partition identifier. This identifier is
           independent on filesystem and does not change by mkfs or
           mkswap operations. It’s supported for example for GUID
           Partition Tables (GPT).

       PARTUUID=<i>uuid</i>
           Partition universally unique identifier. This identifier is
           independent on filesystem and does not change by mkfs or
           mkswap operations. It’s supported for example for GUID
           Partition Tables (GPT).

       ID=<i>id</i>
           Hardware block device ID as generated by udevd. This
           identifier is usually based on WWN (unique storage
           identifier) and assigned by the hardware manufacturer. See <b>ls</b>
           <b>/dev/disk/by-id </b>for more details, this directory and running
           udevd is required. This identifier is not recommended for
           generic use as the identifier is not strictly defined and it
           depends on udev, udev rules and hardware.

       The command <b>lsblk --fs </b>provides an overview of filesystems,
       LABELs and UUIDs on available block devices. The command <b>blkid -p</b>
       <b>&lt;device&gt; </b>provides details about a filesystem on the specified
       device.

       Don’t forget that there is no guarantee that UUIDs and labels are
       really unique, especially if you move, share or copy the device.
       Use <b>lsblk -o +UUID,PARTUUID </b>to verify that the UUIDs are really
       unique in your system.

       The recommended setup is to use tags (e.g. <b>UUID</b>=<i>uuid</i>) rather than
       <i>/dev/disk/by-{label,uuid,id,partuuid,partlabel}</i> udev symlinks in
       the <i>/etc/fstab</i> file. Tags are more readable, robust and portable.
       The <a href="https://man7.org/linux/man-pages/man8/mount.8.html">mount(8)</a> command internally uses udev symlinks, so the use of
       symlinks in <i>/etc/fstab</i> has no advantage over tags. For more
       details see <a href="https://man7.org/linux/man-pages/man3/libblkid.3.html">libblkid(3)</a>.

       The <i>proc</i> filesystem is not associated with a special device, and
       when mounting it, an arbitrary keyword - for example, <i>proc</i> - can
       be used instead of a device specification. (The customary choice
       <i>none</i> is less fortunate: the error message 'none already mounted'
       from <b>mount </b>can be confusing.)

   <b>The files /etc/fstab, /etc/mtab and /proc/mounts</b>
       The file <i>/etc/fstab</i> (see <a href="https://man7.org/linux/man-pages/man5/fstab.5.html">fstab(5)</a>), may contain lines describing
       what devices are usually mounted where, using which options. The
       default location of the <a href="https://man7.org/linux/man-pages/man5/fstab.5.html">fstab(5)</a> file can be overridden with the
       <b>--fstab </b><i>path</i> command-line option (see below for more details).

       The command

          <b>mount -a </b>[<b>-t </b><i>type</i>] [<b>-O </b><i>optlist</i>]

       (usually given in a bootscript) causes all filesystems mentioned
       in <i>fstab</i> (of the proper type and/or having or not having the
       proper options) to be mounted as indicated, except for those
       whose line contains the <b>noauto </b>keyword. Adding the <b>-F </b>option will
       make <b>mount </b>fork, so that the filesystems are mounted in parallel.

       When mounting a filesystem mentioned in <i>fstab</i> or <i>mtab</i>, it
       suffices to specify on the command line only the device, or only
       the mount point.

       The programs <b>mount </b>and <a href="https://man7.org/linux/man-pages/man8/umount.8.html">umount(8)</a> traditionally maintained a list
       of currently mounted filesystems in the file <i>/etc/mtab</i>. The
       support for regular classic <i>/etc/mtab</i> is completely disabled at
       compile time by default, because on current Linux systems it is
       better to make <i>/etc/mtab</i> a symlink to <i>/proc/mounts</i> instead. The
       regular <i>mtab</i> file maintained in userspace cannot reliably work
       with namespaces, containers and other advanced Linux features. If
       the regular <i>mtab</i> support is enabled, then it’s possible to use
       the file as well as the symlink.

       If no arguments are given to <b>mount</b>, the list of mounted
       filesystems is printed.

       If you want to override mount options from <i>/etc/fstab</i>, you have
       to use the <b>-o </b>option:

          <b>mount </b><i>device</i>*<b>*</b>|<i>dir</i> <b>-o </b><i>options</i>

       and then the mount options from the command line will be appended
       to the list of options from <i>/etc/fstab</i>. This default behaviour
       can be changed using the <b>--options-mode </b>command-line option. The
       usual behavior is that the last option wins if there are
       conflicting ones.

       The <b>mount </b>program does not read the <i>/etc/fstab</i> file if both
       <i>device</i> (or LABEL, UUID, ID, PARTUUID or PARTLABEL) and <i>dir</i> are
       specified. For example, to mount device <b>foo </b>at <b>/dir</b>:

          <b>mount /dev/foo /dir</b>

       This default behaviour can be changed by using the
       <b>--options-source-force </b>command-line option to always read
       configuration from <i>fstab</i>. For non-root users <b>mount </b>always reads
       the <i>fstab</i> configuration.

   <b>Non-superuser mounts</b>
       Normally, only the superuser can mount filesystems. However, when
       <i>fstab</i> contains the <b>user </b>option on a line, anybody can mount the
       corresponding filesystem.

       Thus, given a line

          <b>/dev/cdrom /cd iso9660 ro,user,noauto,unhide</b>

       any user can mount the iso9660 filesystem found on an inserted
       CDROM using the command:

          <b>mount /cd</b>

       Note that <b>mount </b>is very strict about non-root users and all paths
       specified on command line are verified before <i>fstab</i> is parsed or
       a helper program is executed. It’s strongly recommended to use a
       valid mountpoint to specify filesystem, otherwise <b>mount </b>may fail.
       For example it’s a bad idea to use NFS or CIFS source on command
       line.

       Since util-linux 2.35, <b>mount </b>does not exit when user permissions
       are inadequate according to libmount’s internal security rules.
       Instead, it drops suid permissions and continues as regular
       non-root user. This behavior supports use-cases where root
       permissions are not necessary (e.g., fuse filesystems, user
       namespaces, etc).

       For more details, see <a href="https://man7.org/linux/man-pages/man5/fstab.5.html">fstab(5)</a>. Only the user that mounted a
       filesystem can unmount it again. If any user should be able to
       unmount it, then use <b>users </b>instead of <b>user </b>in the <i>fstab</i> line. The
       <b>owner </b>option is similar to the <b>user </b>option, with the restriction
       that the user must be the owner of the special file. This may be
       useful e.g. for <i>/dev/fd</i> if a login script makes the console user
       owner of this device. The <b>group </b>option is similar, with the
       restriction that the user must be a member of the group of the
       special file.

   <b>Bind mount operation</b>
       Remount part of the file hierarchy somewhere else. The call is:

          <b>mount --bind </b><i>olddir newdir</i>

       or by using this <i>fstab</i> entry:

          <b>/</b><i>olddir</i> <b>/</b><i>newdir</i> <b>none bind</b>

       After this call the same contents are accessible in two places.

       It is important to understand that "bind" does not create any
       second-class or special node in the kernel VFS. The "bind" is
       just another operation to attach a filesystem. There is nowhere
       stored information that the filesystem has been attached by a
       "bind" operation. The <i>olddir</i> and <i>newdir</i> are independent and the
       <i>olddir</i> may be unmounted.

       One can also remount a single file (on a single file). It’s also
       possible to use a bind mount to create a mountpoint from a
       regular directory, for example:

          <b>mount --bind foo foo</b>

       The bind mount call attaches only (part of) a single filesystem,
       not possible submounts. The entire file hierarchy including
       submounts can be attached a second place by using:

          <b>mount --rbind </b><i>olddir newdir</i>

       Note that the filesystem mount options maintained by the kernel
       will remain the same as those on the original mount point. The
       userspace mount options (e.g., _netdev) will not be copied by
       <b>mount </b>and it’s necessary to explicitly specify the options on the
       <b>mount </b>command line.

       Since util-linux 2.27 <b>mount </b>permits changing the mount options by
       passing the relevant options along with <b>--bind</b>. For example:

          <b>mount -o bind,ro foo foo</b>

       This feature is not supported by the Linux kernel; it is
       implemented in userspace by an additional <a href="https://man7.org/linux/man-pages/man2/mount.2.html">mount(2)</a> remounting
       system call. This solution is not atomic.

       The alternative (classic) way to create a read-only bind mount is
       to use the remount operation, for example:

          <b>mount --bind </b><i>olddir newdir</i> <b>mount -o remount,bind,ro</b>
          <i>olddir newdir</i>

       Note that a read-only bind will create a read-only mountpoint
       (VFS entry), but the original filesystem superblock will still be
       writable, meaning that the <i>olddir</i> will be writable, but the
       <i>newdir</i> will be read-only.

       It’s also possible to change nosuid, nodev, noexec, noatime,
       nodiratime and relatime VFS entry flags via a "remount,bind"
       operation. The other flags (for example filesystem-specific
       flags) are silently ignored. It’s impossible to change mount
       options recursively (for example with <b>-o rbind,ro</b>).

       Since util-linux 2.31, <b>mount </b>ignores the <b>bind </b>flag from
       <i>/etc/fstab</i> on a <b>remount </b>operation (if "-o remount" is specified
       on command line). This is necessary to fully control mount
       options on remount by command line. In previous versions the bind
       flag has been always applied and it was impossible to re-define
       mount options without interaction with the bind semantic. This
       <b>mount </b>behavior does not affect situations when "remount,bind" is
       specified in the <i>/etc/fstab</i> file.

   <b>The move operation</b>
       Move a <b>mounted tree </b>to another place (atomically). The call is:

          <b>mount --move </b><i>olddir newdir</i>

       This will cause the contents which previously appeared under
       <i>olddir</i> to now be accessible under <i>newdir</i>. The physical location
       of the files is not changed. Note that <i>olddir</i> has to be a
       mountpoint.

       Note also that moving a mount residing under a shared mount is
       invalid and unsupported. Use <b>findmnt -o TARGET,PROPAGATION </b>to see
       the current propagation flags.

   <b>Shared subtree operations</b>
       Since Linux 2.6.15 it is possible to mark a mount and its
       submounts as shared, private, slave or unbindable. A shared mount
       provides the ability to create mirrors of that mount such that
       mounts and unmounts within any of the mirrors propagate to the
       other mirror. A slave mount receives propagation from its master,
       but not vice versa. A private mount carries no propagation
       abilities. An unbindable mount is a private mount which cannot be
       cloned through a bind operation. The detailed semantics are
       documented in <i>Documentation/filesystems/sharedsubtree.txt</i> file in
       the kernel source tree; see also <a href="https://man7.org/linux/man-pages/man7/mount_namespaces.7.html">mount_namespaces(7)</a>.

       Supported operations are:

           mount --make-shared mountpoint
           mount --make-slave mountpoint
           mount --make-private mountpoint
           mount --make-unbindable mountpoint

       The following commands allow one to recursively change the type
       of all the mounts under a given mountpoint.

           mount --make-rshared mountpoint
           mount --make-rslave mountpoint
           mount --make-rprivate mountpoint
           mount --make-runbindable mountpoint

       <a href="https://man7.org/linux/man-pages/man8/mount.8.html">mount(8)</a> <b>does not read fstab</b>(5) when a <b>--make-</b>* operation is
       requested. All necessary information has to be specified on the
       command line.

       Note that the Linux kernel does not allow changing multiple
       propagation flags with a single <a href="https://man7.org/linux/man-pages/man2/mount.2.html">mount(2)</a> system call, and the
       flags cannot be mixed with other mount options and operations.

       Since util-linux 2.23 the <b>mount </b>command can be used to do more
       propagation (topology) changes by one <a href="https://man7.org/linux/man-pages/man8/mount.8.html">mount(8)</a> call and do it
       also together with other mount operations. The propagation flags
       are applied by additional <a href="https://man7.org/linux/man-pages/man2/mount.2.html">mount(2)</a> system calls when the
       preceding mount operations were successful. Note that this use
       case is not atomic. It is possible to specify the propagation
       flags in <a href="https://man7.org/linux/man-pages/man5/fstab.5.html">fstab(5)</a> as mount options (<b>private</b>, <b>slave</b>, <b>shared</b>,
       <b>unbindable</b>, <b>rprivate</b>, <b>rslave</b>, <b>rshared</b>, <b>runbindable</b>).

       For example:

           mount --make-private --make-unbindable /dev/sda1 /foo

       is the same as:

           mount /dev/sda1 /foo
           mount --make-private /foo
           mount --make-unbindable /foo
</pre>