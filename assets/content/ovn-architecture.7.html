<pre>
       OVN, the Open Virtual Network, is a system to support virtual
       network abstraction. OVN complements the existing capabilities of
       OVS to add native support for virtual network abstractions, such
       as virtual L2 and L3 overlays and security groups. Services such
       as DHCP are also desirable features. Just like OVS, OVN’s design
       goal is to have a production-quality implementation that can
       operate at significant scale.

       An OVN deployment consists of several components:

              •      A <i>Cloud Management System</i> (<i>CMS</i>), which is OVN’s
                     ultimate client (via its users and administrators).
                     OVN integration requires installing a CMS-specific
                     plugin and related software (see below). OVN
                     initially targets OpenStack as CMS.

                     We generally speak of ``the’’ CMS, but one can
                     imagine scenarios in which multiple CMSes manage
                     different parts of an OVN deployment.

              •      An OVN Database physical or virtual node (or,
                     eventually, cluster) installed in a central
                     location.

              •      One or more (usually many) <i>hypervisors</i>. Hypervisors
                     must run Open vSwitch and implement the interface
                     described in <b>IntegrationGuide.rst </b>in the OVS source
                     tree. Any hypervisor platform supported by Open
                     vSwitch is acceptable.

              •      Zero or more <i>gateways</i>. A gateway extends a tunnel-
                     based logical network into a physical network by
                     bidirectionally forwarding packets between tunnels
                     and a physical Ethernet port. This allows non-
                     virtualized machines to participate in logical
                     networks. A gateway may be a physical host, a
                     virtual machine, or an ASIC-based hardware switch
                     that supports the <a href="https://man7.org/linux/man-pages/man5/vtep.5.html">vtep(5)</a> schema.

                     Hypervisors and gateways are together called
                     <i>transport node</i> or <i>chassis</i>.

       The diagram below shows how the major components of OVN and
       related software interact. Starting at the top of the diagram, we
       have:

              •      The Cloud Management System, as defined above.

              •      The <i>OVN/CMS Plugin</i> is the component of the CMS that
                     interfaces to OVN. In OpenStack, this is a Neutron
                     plugin. The plugin’s main purpose is to translate
                     the CMS’s notion of logical network configuration,
                     stored in the CMS’s configuration database in a
                     CMS-specific format, into an intermediate
                     representation understood by OVN.

                     This component is necessarily CMS-specific, so a
                     new plugin needs to be developed for each CMS that
                     is integrated with OVN. All of the components below
                     this one in the diagram are CMS-independent.

              •      The <i>OVN Northbound Database</i> receives the
                     intermediate representation of logical network
                     configuration passed down by the OVN/CMS Plugin.
                     The database schema is meant to be ``impedance
                     matched’’ with the concepts used in a CMS, so that
                     it directly supports notions of logical switches,
                     routers, ACLs, and so on. See <a href="https://man7.org/linux/man-pages/man5/ovn-nb.5.html">ovn-nb(5)</a> for
                     details.

                     The OVN Northbound Database has only two clients:
                     the OVN/CMS Plugin above it and <b>ovn-northd </b>below
                     it.

              •      <a href="https://man7.org/linux/man-pages/man8/ovn-northd.8.html">ovn-northd(8)</a> connects to the OVN Northbound
                     Database above it and the OVN Southbound Database
                     below it. It translates the logical network
                     configuration in terms of conventional network
                     concepts, taken from the OVN Northbound Database,
                     into logical datapath flows in the OVN Southbound
                     Database below it.

              •      The <i>OVN Southbound Database</i> is the center of the
                     system. Its clients are <a href="https://man7.org/linux/man-pages/man8/ovn-northd.8.html">ovn-northd(8)</a> above it and
                     <a href="https://man7.org/linux/man-pages/man8/ovn-controller.8.html">ovn-controller(8)</a> on every transport node below it.

                     The OVN Southbound Database contains three kinds of
                     data: <i>Physical Network</i> (PN) tables that specify how
                     to reach hypervisor and other nodes, <i>Logical</i>
                     <i>Network</i> (LN) tables that describe the logical
                     network in terms of ``logical datapath flows,’’ and
                     <i>Binding</i> tables that link logical network
                     components’ locations to the physical network. The
                     hypervisors populate the PN and Port_Binding
                     tables, whereas <a href="https://man7.org/linux/man-pages/man8/ovn-northd.8.html">ovn-northd(8)</a> populates the LN
                     tables.

                     OVN Southbound Database performance must scale with
                     the number of transport nodes. This will likely
                     require some work on <a href="https://man7.org/linux/man-pages/man1/ovsdb-server.1.html">ovsdb-server(1)</a> as we
                     encounter bottlenecks. Clustering for availability
                     may be needed.

       The remaining components are replicated onto each hypervisor:

              •      <a href="https://man7.org/linux/man-pages/man8/ovn-controller.8.html">ovn-controller(8)</a> is OVN’s agent on each hypervisor
                     and software gateway. Northbound, it connects to
                     the OVN Southbound Database to learn about OVN
                     configuration and status and to populate the PN
                     table and the <b>Chassis </b>column in <b>Binding </b>table with
                     the hypervisor’s status. Southbound, it connects to
                     <a href="https://man7.org/linux/man-pages/man8/ovs-vswitchd.8.html">ovs-vswitchd(8)</a> as an OpenFlow controller, for
                     control over network traffic, and to the local
                     <a href="https://man7.org/linux/man-pages/man1/ovsdb-server.1.html">ovsdb-server(1)</a> to allow it to monitor and control
                     Open vSwitch configuration.

              •      <a href="https://man7.org/linux/man-pages/man8/ovs-vswitchd.8.html">ovs-vswitchd(8)</a> and <a href="https://man7.org/linux/man-pages/man1/ovsdb-server.1.html">ovsdb-server(1)</a> are
                     conventional components of Open vSwitch.

                                         CMS
                                          |
                                          |
                              +-----------|-----------+
                              |           |           |
                              |     OVN/CMS Plugin    |
                              |           |           |
                              |           |           |
                              |   OVN Northbound DB   |
                              |           |           |
                              |           |           |
                              |       ovn-northd      |
                              |           |           |
                              +-----------|-----------+
                                          |
                                          |
                                +-------------------+
                                | OVN Southbound DB |
                                +-------------------+
                                          |
                                          |
                       +------------------+------------------+
                       |                  |                  |
         HV 1          |                  |    HV n          |
       +---------------|---------------+  .  +---------------|---------------+
       |               |               |  .  |               |               |
       |        ovn-controller         |  .  |        ovn-controller         |
       |         |          |          |  .  |         |          |          |
       |         |          |          |     |         |          |          |
       |  ovs-vswitchd   ovsdb-server  |     |  ovs-vswitchd   ovsdb-server  |
       |                               |     |                               |
       +-------------------------------+     +-------------------------------+

   <b>Information Flow in OVN</b>
       Configuration data in OVN flows from north to south. The CMS,
       through its OVN/CMS plugin, passes the logical network
       configuration to <b>ovn-northd </b>via the northbound database. In turn,
       <b>ovn-northd </b>compiles the configuration into a lower-level form and
       passes it to all of the chassis via the southbound database.

       Status information in OVN flows from south to north. OVN
       currently provides only a few forms of status information. First,
       <b>ovn-northd </b>populates the <b>up </b>column in the northbound
       <b>Logical_Switch_Port </b>table: if a logical port’s <b>chassis </b>column in
       the southbound <b>Port_Binding </b>table is nonempty, it sets <b>up </b>to
       <b>true</b>, otherwise to <b>false</b>. This allows the CMS to detect when a
       VM’s networking has come up.

       Second, OVN provides feedback to the CMS on the realization of
       its configuration, that is, whether the configuration provided by
       the CMS has taken effect. This feature requires the CMS to
       participate in a sequence number protocol, which works the
       following way:

              1.  When the CMS updates the configuration in the
                  northbound database, as part of the same transaction,
                  it increments the value of the <b>nb_cfg </b>column in the
                  <b>NB_Global </b>table. (This is only necessary if the CMS
                  wants to know when the configuration has been
                  realized.)

              2.  When <b>ovn-northd </b>updates the southbound database based
                  on a given snapshot of the northbound database, it
                  copies <b>nb_cfg </b>from northbound <b>NB_Global </b>into the
                  southbound database <b>SB_Global </b>table, as part of the
                  same transaction. (Thus, an observer monitoring both
                  databases can determine when the southbound database
                  is caught up with the northbound.)

              3.  After <b>ovn-northd </b>receives confirmation from the
                  southbound database server that its changes have
                  committed, it updates <b>sb_cfg </b>in the northbound
                  <b>NB_Global </b>table to the <b>nb_cfg </b>version that was pushed
                  down. (Thus, the CMS or another observer can determine
                  when the southbound database is caught up without a
                  connection to the southbound database.)

              4.  The <b>ovn-controller </b>process on each chassis receives
                  the updated southbound database, with the updated
                  <b>nb_cfg</b>. This process in turn updates the physical
                  flows installed in the chassis’s Open vSwitch
                  instances. When it receives confirmation from Open
                  vSwitch that the physical flows have been updated, it
                  updates <b>nb_cfg </b>in its own <b>Chassis </b>record in the
                  southbound database.

              5.  <b>ovn-northd </b>monitors the <b>nb_cfg </b>column in all of the
                  <b>Chassis </b>records in the southbound database. It keeps
                  track of the minimum value among all the records and
                  copies it into the <b>hv_cfg </b>column in the northbound
                  <b>NB_Global </b>table. (Thus, the CMS or another observer
                  can determine when all of the hypervisors have caught
                  up to the northbound configuration.)

   <b>Chassis Setup</b>
       Each chassis in an OVN deployment must be configured with an Open
       vSwitch bridge dedicated for OVN’s use, called the <i>integration</i>
       <i>bridge</i>. System startup scripts may create this bridge prior to
       starting <b>ovn-controller </b>if desired. If this bridge does not exist
       when ovn-controller starts, it will be created automatically with
       the default configuration suggested below. The ports on the
       integration bridge include:

              •      On any chassis, tunnel ports that OVN uses to
                     maintain logical network connectivity.
                     <b>ovn-controller </b>adds, updates, and removes these
                     tunnel ports.

              •      On a hypervisor, any VIFs that are to be attached
                     to logical networks. The hypervisor itself, or the
                     integration between Open vSwitch and the hypervisor
                     (described in <b>IntegrationGuide.rst</b>) takes care of
                     this. (This is not part of OVN or new to OVN; this
                     is pre-existing integration work that has already
                     been done on hypervisors that support OVS.)

              •      On a gateway, the physical port used for logical
                     network connectivity. System startup scripts add
                     this port to the bridge prior to starting
                     <b>ovn-controller</b>. This can be a patch port to another
                     bridge, instead of a physical port, in more
                     sophisticated setups.

       Other ports should not be attached to the integration bridge. In
       particular, physical ports attached to the underlay network (as
       opposed to gateway ports, which are physical ports attached to
       logical networks) must not be attached to the integration bridge.
       Underlay physical ports should instead be attached to a separate
       Open vSwitch bridge (they need not be attached to any bridge at
       all, in fact).

       The integration bridge should be configured as described below.
       The effect of each of these settings is documented in
       <a href="https://man7.org/linux/man-pages/man5/ovs-vswitchd.conf.db.5.html">ovs-vswitchd.conf.db(5)</a>:

              <b>fail-mode=secure</b>
                     Avoids switching packets between isolated logical
                     networks before <b>ovn-controller </b>starts up. See
                     <b>Controller Failure Settings </b>in <a href="https://man7.org/linux/man-pages/man8/ovs-vsctl.8.html">ovs-vsctl(8)</a> for
                     more information.

              <b>other-config:disable-in-band=true</b>
                     Suppresses in-band control flows for the
                     integration bridge. It would be unusual for such
                     flows to show up anyway, because OVN uses a local
                     controller (over a Unix domain socket) instead of a
                     remote controller. It’s possible, however, for some
                     other bridge in the same system to have an in-band
                     remote controller, and in that case this suppresses
                     the flows that in-band control would ordinarily set
                     up. Refer to the documentation for more
                     information.

       The customary name for the integration bridge is <b>br-int</b>, but
       another name may be used.

   <b>Logical Networks</b>
       A <i>logical network</i> implements the same concepts as physical
       networks, but they are insulated from the physical network with
       tunnels or other encapsulations. This allows logical networks to
       have separate IP and other address spaces that overlap, without
       conflicting, with those used for physical networks. Logical
       network topologies can be arranged without regard for the
       topologies of the physical networks on which they run.

       Logical network concepts in OVN include:

              •      <i>Logical switches</i>, the logical version of Ethernet
                     switches.

              •      <i>Logical routers</i>, the logical version of IP routers.
                     Logical switches and routers can be connected into
                     sophisticated topologies.

              •      <i>Logical datapaths</i> are the logical version of an
                     OpenFlow switch. Logical switches and routers are
                     both implemented as logical datapaths.

              •      <i>Logical ports</i> represent the points of connectivity
                     in and out of logical switches and logical routers.
                     Some common types of logical ports are:

                     •      Logical ports representing VIFs.

                     •      <i>Localnet ports</i> represent the points of
                            connectivity between logical switches and
                            the physical network. They are implemented
                            as OVS patch ports between the integration
                            bridge and the separate Open vSwitch bridge
                            that underlay physical ports attach to.

                     •      <i>Logical patch ports</i> represent the points of
                            connectivity between logical switches and
                            logical routers, and in some cases between
                            peer logical routers. There is a pair of
                            logical patch ports at each such point of
                            connectivity, one on each side.

                     •      <i>Localport ports</i> represent the points of
                            local connectivity between logical switches
                            and VIFs. These ports are present in every
                            chassis (not bound to any particular one)
                            and traffic from them will never go through
                            a tunnel. A <b>localport </b>is expected to only
                            generate traffic destined for a local
                            destination, typically in response to a
                            request it received. One use case is how
                            OpenStack Neutron uses a <b>localport </b>port for
                            serving metadata to VM’s residing on every
                            hypervisor. A metadata proxy process is
                            attached to this port on every host and all
                            VM’s within the same network will reach it
                            at the same IP/MAC address without any
                            traffic being sent over a tunnel. Further
                            details can be seen at
                            <a href="https://man7.org/linux/man-pagestps://docs.openstack.org/developer/networking-ovn/design/metadata_api.html">https://docs.openstack.org/developer/networking-ovn/design/metadata_api.html</a>.

   <b>Life Cycle of a VIF</b>
       Tables and their schemas presented in isolation are difficult to
       understand. Here’s an example.

       A VIF on a hypervisor is a virtual network interface attached
       either to a VM or a container running directly on that hypervisor
       (This is different from the interface of a container running
       inside a VM).

       The steps in this example refer often to details of the OVN and
       OVN Northbound database schemas. Please see <a href="https://man7.org/linux/man-pages/man5/ovn-sb.5.html">ovn-sb(5)</a> and
       <a href="https://man7.org/linux/man-pages/man5/ovn-nb.5.html">ovn-nb(5)</a>, respectively, for the full story on these databases.

              1.  A VIF’s life cycle begins when a CMS administrator
                  creates a new VIF using the CMS user interface or API
                  and adds it to a switch (one implemented by OVN as a
                  logical switch). The CMS updates its own
                  configuration. This includes associating unique,
                  persistent identifier <i>vif-id</i> and Ethernet address <i>mac</i>
                  with the VIF.

              2.  The CMS plugin updates the OVN Northbound database to
                  include the new VIF, by adding a row to the
                  <b>Logical_Switch_Port </b>table. In the new row, <b>name </b>is
                  <i>vif-id</i>, <b>mac </b>is <i>mac</i>, <b>switch </b>points to the OVN logical
                  switch’s Logical_Switch record, and other columns are
                  initialized appropriately.

              3.  <b>ovn-northd </b>receives the OVN Northbound database
                  update. In turn, it makes the corresponding updates to
                  the OVN Southbound database, by adding rows to the OVN
                  Southbound database <b>Logical_Flow </b>table to reflect the
                  new port, e.g. add a flow to recognize that packets
                  destined to the new port’s MAC address should be
                  delivered to it, and update the flow that delivers
                  broadcast and multicast packets to include the new
                  port. It also creates a record in the <b>Binding </b>table
                  and populates all its columns except the column that
                  identifies the <b>chassis</b>.

              4.  On every hypervisor, <b>ovn-controller </b>receives the
                  <b>Logical_Flow </b>table updates that <b>ovn-northd </b>made in the
                  previous step. As long as the VM that owns the VIF is
                  powered off, <b>ovn-controller </b>cannot do much; it cannot,
                  for example, arrange to send packets to or receive
                  packets from the VIF, because the VIF does not
                  actually exist anywhere.

              5.  Eventually, a user powers on the VM that owns the VIF.
                  On the hypervisor where the VM is powered on, the
                  integration between the hypervisor and Open vSwitch
                  (described in <b>IntegrationGuide.rst</b>) adds the VIF to
                  the OVN integration bridge and stores <i>vif-id</i> in
                  <b>external_ids</b>:<b>iface-id </b>to indicate that the interface
                  is an instantiation of the new VIF. (None of this code
                  is new in OVN; this is pre-existing integration work
                  that has already been done on hypervisors that support
                  OVS.)

              6.  On the hypervisor where the VM is powered on,
                  <b>ovn-controller </b>notices <b>external_ids</b>:<b>iface-id </b>in the
                  new Interface. In response, in the OVN Southbound DB,
                  it updates the <b>Binding </b>table’s <b>chassis </b>column for the
                  row that links the logical port from <b>external_ids</b>:
                  <b>iface-id </b>to the hypervisor. Afterward, <b>ovn-controller</b>
                  updates the local hypervisor’s OpenFlow tables so that
                  packets to and from the VIF are properly handled.

              7.  Some CMS systems, including OpenStack, fully start a
                  VM only when its networking is ready. To support this,
                  <b>ovn-northd </b>notices the <b>chassis </b>column updated for the
                  row in <b>Binding </b>table and pushes this upward by
                  updating the <b>up </b>column in the OVN Northbound
                  database’s <b>Logical_Switch_Port </b>table to indicate that
                  the VIF is now up. The CMS, if it uses this feature,
                  can then react by allowing the VM’s execution to
                  proceed.

              8.  On every hypervisor but the one where the VIF resides,
                  <b>ovn-controller </b>notices the completely populated row in
                  the <b>Binding </b>table. This provides <b>ovn-controller </b>the
                  physical location of the logical port, so each
                  instance updates the OpenFlow tables of its switch
                  (based on logical datapath flows in the OVN DB
                  <b>Logical_Flow </b>table) so that packets to and from the
                  VIF can be properly handled via tunnels.

              9.  Eventually, a user powers off the VM that owns the
                  VIF. On the hypervisor where the VM was powered off,
                  the VIF is deleted from the OVN integration bridge.

              10. On the hypervisor where the VM was powered off,
                  <b>ovn-controller </b>notices that the VIF was deleted. In
                  response, it removes the <b>Chassis </b>column content in the
                  <b>Binding </b>table for the logical port.

              11. On every hypervisor, <b>ovn-controller </b>notices the empty
                  <b>Chassis </b>column in the <b>Binding </b>table’s row for the
                  logical port. This means that <b>ovn-controller </b>no longer
                  knows the physical location of the logical port, so
                  each instance updates its OpenFlow table to reflect
                  that.

              12. Eventually, when the VIF (or its entire VM) is no
                  longer needed by anyone, an administrator deletes the
                  VIF using the CMS user interface or API. The CMS
                  updates its own configuration.

              13. The CMS plugin removes the VIF from the OVN Northbound
                  database, by deleting its row in the
                  <b>Logical_Switch_Port </b>table.

              14. <b>ovn-northd </b>receives the OVN Northbound update and in
                  turn updates the OVN Southbound database accordingly,
                  by removing or updating the rows from the OVN
                  Southbound database <b>Logical_Flow </b>table and <b>Binding</b>
                  table that were related to the now-destroyed VIF.

              15. On every hypervisor, <b>ovn-controller </b>receives the
                  <b>Logical_Flow </b>table updates that <b>ovn-northd </b>made in the
                  previous step. <b>ovn-controller </b>updates OpenFlow tables
                  to reflect the update, although there may not be much
                  to do, since the VIF had already become unreachable
                  when it was removed from the <b>Binding </b>table in a
                  previous step.

   <b>Life Cycle of a Container Interface Inside a VM</b>
       OVN provides virtual network abstractions by converting
       information written in OVN_NB database to OpenFlow flows in each
       hypervisor. Secure virtual networking for multi-tenants can only
       be provided if OVN controller is the only entity that can modify
       flows in Open vSwitch. When the Open vSwitch integration bridge
       resides in the hypervisor, it is a fair assumption to make that
       tenant workloads running inside VMs cannot make any changes to
       Open vSwitch flows.

       If the infrastructure provider trusts the applications inside the
       containers not to break out and modify the Open vSwitch flows,
       then containers can be run in hypervisors. This is also the case
       when containers are run inside the VMs and Open vSwitch
       integration bridge with flows added by OVN controller resides in
       the same VM. For both the above cases, the workflow is the same
       as explained with an example in the previous section ("Life Cycle
       of a VIF").

       This section talks about the life cycle of a container interface
       (CIF) when containers are created in the VMs and the Open vSwitch
       integration bridge resides inside the hypervisor. In this case,
       even if a container application breaks out, other tenants are not
       affected because the containers running inside the VMs cannot
       modify the flows in the Open vSwitch integration bridge.

       When multiple containers are created inside a VM, there are
       multiple CIFs associated with them. The network traffic
       associated with these CIFs need to reach the Open vSwitch
       integration bridge running in the hypervisor for OVN to support
       virtual network abstractions. OVN should also be able to
       distinguish network traffic coming from different CIFs. There are
       two ways to distinguish network traffic of CIFs.

       One way is to provide one VIF for every CIF (1:1 model). This
       means that there could be a lot of network devices in the
       hypervisor. This would slow down OVS because of all the
       additional CPU cycles needed for the management of all the VIFs.
       It would also mean that the entity creating the containers in a
       VM should also be able to create the corresponding VIFs in the
       hypervisor.

       The second way is to provide a single VIF for all the CIFs
       (1:many model). OVN could then distinguish network traffic coming
       from different CIFs via a tag written in every packet. OVN uses
       this mechanism and uses VLAN as the tagging mechanism.

              1.  A CIF’s life cycle begins when a container is spawned
                  inside a VM by the either the same CMS that created
                  the VM or a tenant that owns that VM or even a
                  container Orchestration System that is different than
                  the CMS that initially created the VM. Whoever the
                  entity is, it will need to know the <i>vif-id</i> that is
                  associated with the network interface of the VM
                  through which the container interface’s network
                  traffic is expected to go through. The entity that
                  creates the container interface will also need to
                  choose an unused VLAN inside that VM.

              2.  The container spawning entity (either directly or
                  through the CMS that manages the underlying
                  infrastructure) updates the OVN Northbound database to
                  include the new CIF, by adding a row to the
                  <b>Logical_Switch_Port </b>table. In the new row, <b>name </b>is any
                  unique identifier, <b>parent_name </b>is the <i>vif-id</i> of the VM
                  through which the CIF’s network traffic is expected to
                  go through and the <b>tag </b>is the VLAN tag that identifies
                  the network traffic of that CIF.

              3.  <b>ovn-northd </b>receives the OVN Northbound database
                  update. In turn, it makes the corresponding updates to
                  the OVN Southbound database, by adding rows to the OVN
                  Southbound database’s <b>Logical_Flow </b>table to reflect
                  the new port and also by creating a new row in the
                  <b>Binding </b>table and populating all its columns except
                  the column that identifies the <b>chassis</b>.

              4.  On every hypervisor, <b>ovn-controller </b>subscribes to the
                  changes in the <b>Binding </b>table. When a new row is
                  created by <b>ovn-northd </b>that includes a value in
                  <b>parent_port </b>column of <b>Binding </b>table, the
                  <b>ovn-controller </b>in the hypervisor whose OVN integration
                  bridge has that same value in <i>vif-id</i> in
                  <b>external_ids</b>:<b>iface-id </b>updates the local hypervisor’s
                  OpenFlow tables so that packets to and from the VIF
                  with the particular VLAN <b>tag </b>are properly handled.
                  Afterward it updates the <b>chassis </b>column of the <b>Binding</b>
                  to reflect the physical location.

              5.  One can only start the application inside the
                  container after the underlying network is ready. To
                  support this, <b>ovn-northd </b>notices the updated <b>chassis</b>
                  column in <b>Binding </b>table and updates the <b>up </b>column in
                  the OVN Northbound database’s <b>Logical_Switch_Port</b>
                  table to indicate that the CIF is now up. The entity
                  responsible to start the container application queries
                  this value and starts the application.

              6.  Eventually the entity that created and started the
                  container, stops it. The entity, through the CMS (or
                  directly) deletes its row in the <b>Logical_Switch_Port</b>
                  table.

              7.  <b>ovn-northd </b>receives the OVN Northbound update and in
                  turn updates the OVN Southbound database accordingly,
                  by removing or updating the rows from the OVN
                  Southbound database <b>Logical_Flow </b>table that were
                  related to the now-destroyed CIF. It also deletes the
                  row in the <b>Binding </b>table for that CIF.

              8.  On every hypervisor, <b>ovn-controller </b>receives the
                  <b>Logical_Flow </b>table updates that <b>ovn-northd </b>made in the
                  previous step. <b>ovn-controller </b>updates OpenFlow tables
                  to reflect the update.

   <b>Architectural Physical Life Cycle of a Packet</b>
       This section describes how a packet travels from one virtual
       machine or container to another through OVN. This description
       focuses on the physical treatment of a packet; for a description
       of the logical life cycle of a packet, please refer to the
       <b>Logical_Flow </b>table in <a href="https://man7.org/linux/man-pages/man5/ovn-sb.5.html">ovn-sb(5)</a>.

       This section mentions several data and metadata fields, for
       clarity summarized here:

              tunnel key
                     When OVN encapsulates a packet in Geneve or another
                     tunnel, it attaches extra data to it to allow the
                     receiving OVN instance to process it correctly.
                     This takes different forms depending on the
                     particular encapsulation, but in each case we refer
                     to it here as the ``tunnel key.’’ See <b>Tunnel</b>
                     <b>Encapsulations</b>, below, for details.

              logical datapath field
                     A field that denotes the logical datapath through
                     which a packet is being processed. OVN uses the
                     field that OpenFlow 1.1+ simply (and confusingly)
                     calls ``metadata’’ to store the logical datapath.
                     (This field is passed across tunnels as part of the
                     tunnel key.)

              logical input port field
                     A field that denotes the logical port from which
                     the packet entered the logical datapath. OVN stores
                     this in Open vSwitch extension register number 14.

                     Geneve and STT tunnels pass this field as part of
                     the tunnel key. Although VXLAN tunnels do not
                     explicitly carry a logical input port, OVN only
                     uses VXLAN to communicate with gateways that from
                     OVN’s perspective consist of only a single logical
                     port, so that OVN can set the logical input port
                     field to this one on ingress to the OVN logical
                     pipeline.

              logical output port field
                     A field that denotes the logical port from which
                     the packet will leave the logical datapath. This is
                     initialized to 0 at the beginning of the logical
                     ingress pipeline. OVN stores this in Open vSwitch
                     extension register number 15.

                     Geneve and STT tunnels pass this field as part of
                     the tunnel key. VXLAN tunnels do not transmit the
                     logical output port field. Since VXLAN tunnels do
                     not carry a logical output port field in the tunnel
                     key, when a packet is received from VXLAN tunnel by
                     an OVN hypervisor, the packet is resubmitted to
                     table 8 to determine the output port(s); when the
                     packet reaches table 32, these packets are
                     resubmitted to table 33 for local delivery by
                     checking a MLF_RCV_FROM_VXLAN flag, which is set
                     when the packet arrives from a VXLAN tunnel.

              conntrack zone field for logical ports
                     A field that denotes the connection tracking zone
                     for logical ports. The value only has local
                     significance and is not meaningful between chassis.
                     This is initialized to 0 at the beginning of the
                     logical ingress pipeline. OVN stores this in Open
                     vSwitch extension register number 13.

              conntrack zone fields for routers
                     Fields that denote the connection tracking zones
                     for routers. These values only have local
                     significance and are not meaningful between
                     chassis. OVN stores the zone information for
                     DNATting in Open vSwitch extension register number
                     11 and zone information for SNATing in Open vSwitch
                     extension register number 12.

              logical flow flags
                     The logical flags are intended to handle keeping
                     context between tables in order to decide which
                     rules in subsequent tables are matched. These
                     values only have local significance and are not
                     meaningful between chassis. OVN stores the logical
                     flags in Open vSwitch extension register number 10.

              VLAN ID
                     The VLAN ID is used as an interface between OVN and
                     containers nested inside a VM (see <b>Life Cycle of a</b>
                     <b>container interface inside a VM</b>, above, for more
                     information).

       Initially, a VM or container on the ingress hypervisor sends a
       packet on a port attached to the OVN integration bridge. Then:

              1.  OpenFlow table 0 performs physical-to-logical
                  translation. It matches the packet’s ingress port. Its
                  actions annotate the packet with logical metadata, by
                  setting the logical datapath field to identify the
                  logical datapath that the packet is traversing and the
                  logical input port field to identify the ingress port.
                  Then it resubmits to table 8 to enter the logical
                  ingress pipeline.

                  Packets that originate from a container nested within
                  a VM are treated in a slightly different way. The
                  originating container can be distinguished based on
                  the VIF-specific VLAN ID, so the physical-to-logical
                  translation flows additionally match on VLAN ID and
                  the actions strip the VLAN header. Following this
                  step, OVN treats packets from containers just like any
                  other packets.

                  Table 0 also processes packets that arrive from other
                  chassis. It distinguishes them from other packets by
                  ingress port, which is a tunnel. As with packets just
                  entering the OVN pipeline, the actions annotate these
                  packets with logical datapath and logical ingress port
                  metadata. In addition, the actions set the logical
                  output port field, which is available because in OVN
                  tunneling occurs after the logical output port is
                  known. These three pieces of information are obtained
                  from the tunnel encapsulation metadata (see <b>Tunnel</b>
                  <b>Encapsulations </b>for encoding details). Then the actions
                  resubmit to table 33 to enter the logical egress
                  pipeline.

              2.  OpenFlow tables 8 through 31 execute the logical
                  ingress pipeline from the <b>Logical_Flow </b>table in the
                  OVN Southbound database. These tables are expressed
                  entirely in terms of logical concepts like logical
                  ports and logical datapaths. A big part of
                  <b>ovn-controller</b>’s job is to translate them into
                  equivalent OpenFlow (in particular it translates the
                  table numbers: <b>Logical_Flow </b>tables 0 through 23 become
                  OpenFlow tables 8 through 31).

                  Each logical flow maps to one or more OpenFlow flows.
                  An actual packet ordinarily matches only one of these,
                  although in some cases it can match more than one of
                  these flows (which is not a problem because all of
                  them have the same actions). <b>ovn-controller </b>uses the
                  first 32 bits of the logical flow’s UUID as the cookie
                  for its OpenFlow flow or flows. (This is not
                  necessarily unique, since the first 32 bits of a
                  logical flow’s UUID is not necessarily unique.)

                  Some logical flows can map to the Open vSwitch
                  ``conjunctive match’’ extension (see <a href="https://man7.org/linux/man-pages/man7/ovs-fields.7.html">ovs-fields(7)</a>).
                  Flows with a <b>conjunction </b>action use an OpenFlow cookie
                  of 0, because they can correspond to multiple logical
                  flows. The OpenFlow flow for a conjunctive match
                  includes a match on <b>conj_id</b>.

                  Some logical flows may not be represented in the
                  OpenFlow tables on a given hypervisor, if they could
                  not be used on that hypervisor. For example, if no VIF
                  in a logical switch resides on a given hypervisor, and
                  the logical switch is not otherwise reachable on that
                  hypervisor (e.g. over a series of hops through logical
                  switches and routers starting from a VIF on the
                  hypervisor), then the logical flow may not be
                  represented there.

                  Most OVN actions have fairly obvious implementations
                  in OpenFlow (with OVS extensions), e.g. <b>next; </b>is
                  implemented as <b>resubmit</b>, <i>field</i> <b>= </b><i>constant</i><b>; </b>as
                  <b>set_field</b>. A few are worth describing in more detail:

                  <b>output:</b>
                         Implemented by resubmitting the packet to table
                         32. If the pipeline executes more than one
                         <b>output </b>action, then each one is separately
                         resubmitted to table 32. This can be used to
                         send multiple copies of the packet to multiple
                         ports. (If the packet was not modified between
                         the <b>output </b>actions, and some of the copies are
                         destined to the same hypervisor, then using a
                         logical multicast output port would save
                         bandwidth between hypervisors.)

                  <b>get_arp(</b><i>P</i><b>, </b><i>A</i><b>);</b>
                  <b>get_nd(</b><i>P</i><b>, </b><i>A</i><b>);</b>
                       Implemented by storing arguments into OpenFlow
                       fields, then resubmitting to table 66, which
                       <b>ovn-controller </b>populates with flows generated
                       from the <b>MAC_Binding </b>table in the OVN Southbound
                       database. If there is a match in table 66, then
                       its actions store the bound MAC in the Ethernet
                       destination address field.

                       (The OpenFlow actions save and restore the
                       OpenFlow fields used for the arguments, so that
                       the OVN actions do not have to be aware of this
                       temporary use.)

                  <b>put_arp(</b><i>P</i><b>, </b><i>A</i><b>, </b><i>E</i><b>);</b>
                  <b>put_nd(</b><i>P</i><b>, </b><i>A</i><b>, </b><i>E</i><b>);</b>
                       Implemented by storing the arguments into
                       OpenFlow fields, then outputting a packet to
                       <b>ovn-controller</b>, which updates the <b>MAC_Binding</b>
                       table.

                       (The OpenFlow actions save and restore the
                       OpenFlow fields used for the arguments, so that
                       the OVN actions do not have to be aware of this
                       temporary use.)

              3.  OpenFlow tables 32 through 47 implement the <b>output</b>
                  action in the logical ingress pipeline. Specifically,
                  table 32 handles packets to remote hypervisors, table
                  33 handles packets to the local hypervisor, and table
                  34 checks whether packets whose logical ingress and
                  egress port are the same should be discarded.

                  Logical patch ports are a special case. Logical patch
                  ports do not have a physical location and effectively
                  reside on every hypervisor. Thus, flow table 33, for
                  output to ports on the local hypervisor, naturally
                  implements output to unicast logical patch ports too.
                  However, applying the same logic to a logical patch
                  port that is part of a logical multicast group yields
                  packet duplication, because each hypervisor that
                  contains a logical port in the multicast group will
                  also output the packet to the logical patch port.
                  Thus, multicast groups implement output to logical
                  patch ports in table 32.

                  Each flow in table 32 matches on a logical output port
                  for unicast or multicast logical ports that include a
                  logical port on a remote hypervisor. Each flow’s
                  actions implement sending a packet to the port it
                  matches. For unicast logical output ports on remote
                  hypervisors, the actions set the tunnel key to the
                  correct value, then send the packet on the tunnel port
                  to the correct hypervisor. (When the remote hypervisor
                  receives the packet, table 0 there will recognize it
                  as a tunneled packet and pass it along to table 33.)
                  For multicast logical output ports, the actions send
                  one copy of the packet to each remote hypervisor, in
                  the same way as for unicast destinations. If a
                  multicast group includes a logical port or ports on
                  the local hypervisor, then its actions also resubmit
                  to table 33. Table 32 also includes:

                  •      A higher-priority rule to match packets
                         received from VXLAN tunnels, based on flag
                         MLF_RCV_FROM_VXLAN, and resubmit these packets
                         to table 33 for local delivery. Packets
                         received from VXLAN tunnels reach here because
                         of a lack of logical output port field in the
                         tunnel key and thus these packets needed to be
                         submitted to table 8 to determine the output
                         port.

                  •      A higher-priority rule to match packets
                         received from ports of type <b>localport</b>, based on
                         the logical input port, and resubmit these
                         packets to table 33 for local delivery. Ports
                         of type <b>localport </b>exist on every hypervisor and
                         by definition their traffic should never go out
                         through a tunnel.

                  •      A higher-priority rule to match packets that
                         have the MLF_LOCAL_ONLY logical flow flag set,
                         and whose destination is a multicast address.
                         This flag indicates that the packet should not
                         be delivered to remote hypervisors, even if the
                         multicast destination includes ports on remote
                         hypervisors. This flag is used when
                         <b>ovn-controller </b>is the originator of the
                         multicast packet. Since each <b>ovn-controller</b>
                         instance is originating these packets, the
                         packets only need to be delivered to local
                         ports.

                  •      A fallback flow that resubmits to table 33 if
                         there is no other match.

                  Flows in table 33 resemble those in table 32 but for
                  logical ports that reside locally rather than
                  remotely. For unicast logical output ports on the
                  local hypervisor, the actions just resubmit to table
                  34. For multicast output ports that include one or
                  more logical ports on the local hypervisor, for each
                  such logical port <i>P</i>, the actions change the logical
                  output port to <i>P</i>, then resubmit to table 34.

                  A special case is that when a localnet port exists on
                  the datapath, remote port is connected by switching to
                  the localnet port. In this case, instead of adding a
                  flow in table 32 to reach the remote port, a flow is
                  added in table 33 to switch the logical outport to the
                  localnet port, and resubmit to table 33 as if it were
                  unicasted to a logical port on the local hypervisor.

                  Table 34 matches and drops packets for which the
                  logical input and output ports are the same and the
                  MLF_ALLOW_LOOPBACK flag is not set. It resubmits other
                  packets to table 40.

              4.  OpenFlow tables 40 through 63 execute the logical
                  egress pipeline from the <b>Logical_Flow </b>table in the OVN
                  Southbound database. The egress pipeline can perform a
                  final stage of validation before packet delivery.
                  Eventually, it may execute an <b>output </b>action, which
                  <b>ovn-controller </b>implements by resubmitting to table 64.
                  A packet for which the pipeline never executes <b>output</b>
                  is effectively dropped (although it may have been
                  transmitted through a tunnel across a physical
                  network).

                  The egress pipeline cannot change the logical output
                  port or cause further tunneling.

              5.  Table 64 bypasses OpenFlow loopback when
                  MLF_ALLOW_LOOPBACK is set. Logical loopback was
                  handled in table 34, but OpenFlow by default also
                  prevents loopback to the OpenFlow ingress port. Thus,
                  when MLF_ALLOW_LOOPBACK is set, OpenFlow table 64
                  saves the OpenFlow ingress port, sets it to zero,
                  resubmits to table 65 for logical-to-physical
                  transformation, and then restores the OpenFlow ingress
                  port, effectively disabling OpenFlow loopback
                  prevents. When MLF_ALLOW_LOOPBACK is unset, table 64
                  flow simply resubmits to table 65.

              6.  OpenFlow table 65 performs logical-to-physical
                  translation, the opposite of table 0. It matches the
                  packet’s logical egress port. Its actions output the
                  packet to the port attached to the OVN integration
                  bridge that represents that logical port. If the
                  logical egress port is a container nested with a VM,
                  then before sending the packet the actions push on a
                  VLAN header with an appropriate VLAN ID.

   <b>Logical Routers and Logical Patch Ports</b>
       Typically logical routers and logical patch ports do not have a
       physical location and effectively reside on every hypervisor.
       This is the case for logical patch ports between logical routers
       and logical switches behind those logical routers, to which VMs
       (and VIFs) attach.

       Consider a packet sent from one virtual machine or container to
       another VM or container that resides on a different subnet. The
       packet will traverse tables 0 to 65 as described in the previous
       section <b>Architectural Physical Life Cycle of a Packet</b>, using the
       logical datapath representing the logical switch that the sender
       is attached to. At table 32, the packet will use the fallback
       flow that resubmits locally to table 33 on the same hypervisor.
       In this case, all of the processing from table 0 to table 65
       occurs on the hypervisor where the sender resides.

       When the packet reaches table 65, the logical egress port is a
       logical patch port. The implementation in table 65 differs
       depending on the OVS version, although the observed behavior is
       meant to be the same:

              •      In OVS versions 2.6 and earlier, table 65 outputs
                     to an OVS patch port that represents the logical
                     patch port. The packet re-enters the OpenFlow flow
                     table from the OVS patch port’s peer in table 0,
                     which identifies the logical datapath and logical
                     input port based on the OVS patch port’s OpenFlow
                     port number.

              •      In OVS versions 2.7 and later, the packet is cloned
                     and resubmitted directly to the first OpenFlow flow
                     table in the ingress pipeline, setting the logical
                     ingress port to the peer logical patch port, and
                     using the peer logical patch port’s logical
                     datapath (that represents the logical router).

       The packet re-enters the ingress pipeline in order to traverse
       tables 8 to 65 again, this time using the logical datapath
       representing the logical router. The processing continues as
       described in the previous section <b>Architectural Physical Life</b>
       <b>Cycle of a Packet</b>. When the packet reachs table 65, the logical
       egress port will once again be a logical patch port. In the same
       manner as described above, this logical patch port will cause the
       packet to be resubmitted to OpenFlow tables 8 to 65, this time
       using the logical datapath representing the logical switch that
       the destination VM or container is attached to.

       The packet traverses tables 8 to 65 a third and final time. If
       the destination VM or container resides on a remote hypervisor,
       then table 32 will send the packet on a tunnel port from the
       sender’s hypervisor to the remote hypervisor. Finally table 65
       will output the packet directly to the destination VM or
       container.

       The following sections describe two exceptions, where logical
       routers and/or logical patch ports are associated with a physical
       location.

     <i>Gateway Routers</i>

       A <i>gateway router</i> is a logical router that is bound to a physical
       location. This includes all of the logical patch ports of the
       logical router, as well as all of the peer logical patch ports on
       logical switches. In the OVN Southbound database, the
       <b>Port_Binding </b>entries for these logical patch ports use the type
       <b>l3gateway </b>rather than <b>patch</b>, in order to distinguish that these
       logical patch ports are bound to a chassis.

       When a hypervisor processes a packet on a logical datapath
       representing a logical switch, and the logical egress port is a
       <b>l3gateway </b>port representing connectivity to a gateway router, the
       packet will match a flow in table 32 that sends the packet on a
       tunnel port to the chassis where the gateway router resides. This
       processing in table 32 is done in the same manner as for VIFs.

       Gateway routers are typically used in between distributed logical
       routers and physical networks. The distributed logical router and
       the logical switches behind it, to which VMs and containers
       attach, effectively reside on each hypervisor. The distributed
       router and the gateway router are connected by another logical
       switch, sometimes referred to as a <b>join </b>logical switch. On the
       other side, the gateway router connects to another logical switch
       that has a localnet port connecting to the physical network.

       When using gateway routers, DNAT and SNAT rules are associated
       with the gateway router, which provides a central location that
       can handle one-to-many SNAT (aka IP masquerading).

     <i>Distributed Gateway Ports</i>

       <i>Distributed gateway ports</i> are logical router patch ports that
       directly connect distributed logical routers to logical switches
       with localnet ports.

       The primary design goal of distributed gateway ports is to allow
       as much traffic as possible to be handled locally on the
       hypervisor where a VM or container resides. Whenever possible,
       packets from the VM or container to the outside world should be
       processed completely on that VM’s or container’s hypervisor,
       eventually traversing a localnet port instance on that hypervisor
       to the physical network. Whenever possible, packets from the
       outside world to a VM or container should be directed through the
       physical network directly to the VM’s or container’s hypervisor,
       where the packet will enter the integration bridge through a
       localnet port.

       In order to allow for the distributed processing of packets
       described in the paragraph above, distributed gateway ports need
       to be logical patch ports that effectively reside on every
       hypervisor, rather than <b>l3gateway </b>ports that are bound to a
       particular chassis. However, the flows associated with
       distributed gateway ports often need to be associated with
       physical locations, for the following reasons:

              •      The physical network that the localnet port is
                     attached to typically uses L2 learning. Any
                     Ethernet address used over the distributed gateway
                     port must be restricted to a single physical
                     location so that upstream L2 learning is not
                     confused. Traffic sent out the distributed gateway
                     port towards the localnet port with a specific
                     Ethernet address must be sent out one specific
                     instance of the distributed gateway port on one
                     specific chassis. Traffic received from the
                     localnet port (or from a VIF on the same logical
                     switch as the localnet port) with a specific
                     Ethernet address must be directed to the logical
                     switch’s patch port instance on that specific
                     chassis.

                     Due to the implications of L2 learning, the
                     Ethernet address and IP address of the distributed
                     gateway port need to be restricted to a single
                     physical location. For this reason, the user must
                     specify one chassis associated with the distributed
                     gateway port. Note that traffic traversing the
                     distributed gateway port using other Ethernet
                     addresses and IP addresses (e.g. one-to-one NAT) is
                     not restricted to this chassis.

                     Replies to ARP and ND requests must be restricted
                     to a single physical location, where the Ethernet
                     address in the reply resides. This includes ARP and
                     ND replies for the IP address of the distributed
                     gateway port, which are restricted to the chassis
                     that the user associated with the distributed
                     gateway port.

              •      In order to support one-to-many SNAT (aka IP
                     masquerading), where multiple logical IP addresses
                     spread across multiple chassis are mapped to a
                     single external IP address, it will be necessary to
                     handle some of the logical router processing on a
                     specific chassis in a centralized manner. Since the
                     SNAT external IP address is typically the
                     distributed gateway port IP address, and for
                     simplicity, the same chassis associated with the
                     distributed gateway port is used.

       The details of flow restrictions to specific chassis are
       described in the <b>ovn-northd </b>documentation.

       While most of the physical location dependent aspects of
       distributed gateway ports can be handled by restricting some
       flows to specific chassis, one additional mechanism is required.
       When a packet leaves the ingress pipeline and the logical egress
       port is the distributed gateway port, one of two different sets
       of actions is required at table 32:

              •      If the packet can be handled locally on the
                     sender’s hypervisor (e.g. one-to-one NAT traffic),
                     then the packet should just be resubmitted locally
                     to table 33, in the normal manner for distributed
                     logical patch ports.

              •      However, if the packet needs to be handled on the
                     chassis associated with the distributed gateway
                     port (e.g. one-to-many SNAT traffic or non-NAT
                     traffic), then table 32 must send the packet on a
                     tunnel port to that chassis.

       In order to trigger the second set of actions, the
       <b>chassisredirect </b>type of southbound <b>Port_Binding </b>has been added.
       Setting the logical egress port to the type <b>chassisredirect</b>
       logical port is simply a way to indicate that although the packet
       is destined for the distributed gateway port, it needs to be
       redirected to a different chassis. At table 32, packets with this
       logical egress port are sent to a specific chassis, in the same
       way that table 32 directs packets whose logical egress port is a
       VIF or a type <b>l3gateway </b>port to different chassis. Once the
       packet arrives at that chassis, table 33 resets the logical
       egress port to the value representing the distributed gateway
       port. For each distributed gateway port, there is one type
       <b>chassisredirect </b>port, in addition to the distributed logical
       patch port representing the distributed gateway port.

     <i>High Availability for Distributed Gateway Ports</i>

       OVN allows you to specify a prioritized list of chassis for a
       distributed gateway port. This is done by associating multiple
       <b>Gateway_Chassis </b>rows with a <b>Logical_Router_Port </b>in the
       <b>OVN_Northbound </b>database.

       When multiple chassis have been specified for a gateway, all
       chassis that may send packets to that gateway will enable BFD on
       tunnels to all configured gateway chassis. The current master
       chassis for the gateway is the highest priority gateway chassis
       that is currently viewed as active based on BFD status.

       For more information on L3 gateway high availability, please
       refer to
       <a href="https://man7.org/linux/man-pagestp://docs.openvswitch.org/en/latest/topics/high-availability">http://docs.openvswitch.org/en/latest/topics/high-availability</a>.

   <b>Multiple localnet logical switches connected to a Logical Router</b>
       It is possible to have multiple logical switches each with a
       localnet port (representing physical networks) connected to a
       logical router, in which one localnet logical switch may provide
       the external connectivity via a distributed gateway port and rest
       of the localnet logical switches use VLAN tagging in the physical
       network. It is expected that <b>ovn-bridge-mappings </b>is configured
       appropriately on the chassis for all these localnet networks.

     <i>East West routing</i>

       East-West routing between these localnet VLAN tagged logical
       switches work almost the same way as normal logical switches.
       When the VM sends such a packet, then:

              1.  It first enters the ingress pipeline, and then egress
                  pipeline of the source localnet logical switch
                  datapath. It then enters the ingress pipeline of the
                  logical router datapath via the logical router port in
                  the source chassis.

              2.  Routing decision is taken.

              3.  From the router datapath, packet enters the ingress
                  pipeline and then egress pipeline of the destination
                  localnet logical switch datapath and goes out of the
                  integration bridge to the provider bridge ( belonging
                  to the destination logical switch) via the localnet
                  port. While sending the packet to provider bridge, we
                  also replace router port MAC as source MAC with a
                  chassis unique MAC.

                  This chassis unique MAC is configured as global ovs
                  config on each chassis (eg. via "<b>ovs-vsctl set open .</b>
                  <b>external-ids:</b>
                  <b>ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"</b>").
                  For more details, see <a href="https://man7.org/linux/man-pages/man8/ovn-controller.8.html">ovn-controller(8)</a>.

                  If the above is not configured, then source MAC would
                  be the router port MAC. This could create problem if
                  we have more than one chassis. This is because, since
                  the router port is distributed, the same (MAC,VLAN)
                  tuple will seen by physical network from other chassis
                  as well, which could cause these issues:

                  •      Continuous MAC moves in top-of-rack switch
                         (ToR).

                  •      ToR dropping the traffic, which is causing
                         continuous MAC moves.

                  •      ToR blocking the ports from which MAC moves are
                         happening.

              4.  The destination chassis receives the packet via the
                  localnet port and sends it to the integration bridge.
                  The packet enters the ingress pipeline and then egress
                  pipeline of the destination localnet logical switch
                  and finally gets delivered to the destination VM port.

     <i>External traffic</i>

       The following happens when a VM sends an external traffic (which
       requires NATting) and the chassis hosting the VM doesn’t have a
       distributed gateway port.

              1.  The packet first enters the ingress pipeline, and then
                  egress pipeline of the source localnet logical switch
                  datapath. It then enters the ingress pipeline of the
                  logical router datapath via the logical router port in
                  the source chassis.

              2.  Routing decision is taken. Since the gateway router or
                  the distributed gateway port doesn’t reside in the
                  source chassis, the traffic is redirected to the
                  gateway chassis via the tunnel port.

              3.  The gateway chassis receives the packet via the tunnel
                  port and the packet enters the egress pipeline of the
                  logical router datapath. NAT rules are applied here.
                  The packet then enters the ingress pipeline and then
                  egress pipeline of the localnet logical switch
                  datapath which provides external connectivity and
                  finally goes out via the localnet port of the logical
                  switch which provides external connectivity.

       Although this works, the VM traffic is tunnelled when sent from
       the compute chassis to the gateway chassis. In order for it to
       work properly, the MTU of the localnet logical switches must be
       lowered to account for the tunnel encapsulation.

       Centralized routing for localnet VLAN tagged logical switches
       connected to a Logical Router "

       To overcome the tunnel encapsulation problem described in the
       previous section, <b>OVN </b>supports the option of enabling centralized
       routing for localnet VLAN tagged logical switches. CMS can
       configure the option <b>options:reside-on-redirect-chassis </b>to <b>true</b>
       for each <b>Logical_Router_Port </b>which connects to the localnet VLAN
       tagged logical switches. This causes the gateway chassis (hosting
       the distributed gateway port) to handle all the routing for these
       networks, making it centralized. It will reply to the ARP
       requests for the logical router port IPs.

       If the logical router doesn’t have a distributed gateway port
       connecting to the localnet logical switch which provides external
       connectivity, then this option is ignored by <b>OVN</b>.

       The following happens when a VM sends an east-west traffic which
       needs to be routed:

              1.  The packet first enters the ingress pipeline, and then
                  egress pipeline of the source localnet logical switch
                  datapath and is sent out via the localnet port of the
                  source localnet logical switch (instead of sending it
                  to router pipeline).

              2.  The gateway chassis receives the packet via the
                  localnet port of the source localnet logical switch
                  and sends it to the integration bridge. The packet
                  then enters the ingress pipeline, and then egress
                  pipeline of the source localnet logical switch
                  datapath and enters the ingress pipeline of the
                  logical router datapath.

              3.  Routing decision is taken.

              4.  From the router datapath, packet enters the ingress
                  pipeline and then egress pipeline of the destination
                  localnet logical switch datapath. It then goes out of
                  the integration bridge to the provider bridge (
                  belonging to the destination logical switch) via the
                  localnet port.

              5.  The destination chassis receives the packet via the
                  localnet port and sends it to the integration bridge.
                  The packet enters the ingress pipeline and then egress
                  pipeline of the destination localnet logical switch
                  and finally delivered to the destination VM port.

       The following happens when a VM sends an external traffic which
       requires NATting:

              1.  The packet first enters the ingress pipeline, and then
                  egress pipeline of the source localnet logical switch
                  datapath and is sent out via the localnet port of the
                  source localnet logical switch (instead of sending it
                  to router pipeline).

              2.  The gateway chassis receives the packet via the
                  localnet port of the source localnet logical switch
                  and sends it to the integration bridge. The packet
                  then enters the ingress pipeline, and then egress
                  pipeline of the source localnet logical switch
                  datapath and enters the ingress pipeline of the
                  logical router datapath.

              3.  Routing decision is taken and NAT rules are applied.

              4.  From the router datapath, packet enters the ingress
                  pipeline and then egress pipeline of the localnet
                  logical switch datapath which provides external
                  connectivity. It then goes out of the integration
                  bridge to the provider bridge (belonging to the
                  logical switch which provides external connectivity)
                  via the localnet port.

       The following happens for the reverse external traffic.

              1.  The gateway chassis receives the packet from the
                  localnet port of the logical switch which provides
                  external connectivity. The packet then enters the
                  ingress pipeline and then egress pipeline of the
                  localnet logical switch (which provides external
                  connectivity). The packet then enters the ingress
                  pipeline of the logical router datapath.

              2.  The ingress pipeline of the logical router datapath
                  applies the unNATting rules. The packet then enters
                  the ingress pipeline and then egress pipeline of the
                  source localnet logical switch. Since the source VM
                  doesn’t reside in the gateway chassis, the packet is
                  sent out via the localnet port of the source logical
                  switch.

              3.  The source chassis receives the packet via the
                  localnet port and sends it to the integration bridge.
                  The packet enters the ingress pipeline and then egress
                  pipeline of the source localnet logical switch and
                  finally gets delivered to the source VM port.

   <b>Life Cycle of a VTEP gateway</b>
       A gateway is a chassis that forwards traffic between the OVN-
       managed part of a logical network and a physical VLAN, extending
       a tunnel-based logical network into a physical network.

       The steps below refer often to details of the OVN and VTEP
       database schemas. Please see <a href="https://man7.org/linux/man-pages/man5/ovn-sb.5.html">ovn-sb(5)</a>, <a href="https://man7.org/linux/man-pages/man5/ovn-nb.5.html">ovn-nb(5)</a> and <a href="https://man7.org/linux/man-pages/man5/vtep.5.html">vtep(5)</a>,
       respectively, for the full story on these databases.

              1.  A VTEP gateway’s life cycle begins with the
                  administrator registering the VTEP gateway as a
                  <b>Physical_Switch </b>table entry in the <b>VTEP </b>database. The
                  <b>ovn-controller-vtep </b>connected to this VTEP database,
                  will recognize the new VTEP gateway and create a new
                  <b>Chassis </b>table entry for it in the <b>OVN_Southbound</b>
                  database.

              2.  The administrator can then create a new <b>Logical_Switch</b>
                  table entry, and bind a particular vlan on a VTEP
                  gateway’s port to any VTEP logical switch. Once a VTEP
                  logical switch is bound to a VTEP gateway, the
                  <b>ovn-controller-vtep </b>will detect it and add its name to
                  the <i>vtep_logical_switches</i> column of the <b>Chassis </b>table
                  in the <b>OVN_Southbound </b>database. Note, the <i>tunnel_key</i>
                  column of VTEP logical switch is not filled at
                  creation. The <b>ovn-controller-vtep </b>will set the column
                  when the correponding vtep logical switch is bound to
                  an OVN logical network.

              3.  Now, the administrator can use the CMS to add a VTEP
                  logical switch to the OVN logical network. To do that,
                  the CMS must first create a new <b>Logical_Switch_Port</b>
                  table entry in the <b>OVN_Northbound </b>database. Then, the
                  <i>type</i> column of this entry must be set to "vtep". Next,
                  the <i>vtep-logical-switch</i> and <i>vtep-physical-switch</i> keys
                  in the <i>options</i> column must also be specified, since
                  multiple VTEP gateways can attach to the same VTEP
                  logical switch.

              4.  The newly created logical port in the <b>OVN_Northbound</b>
                  database and its configuration will be passed down to
                  the <b>OVN_Southbound </b>database as a new <b>Port_Binding</b>
                  table entry. The <b>ovn-controller-vtep </b>will recognize
                  the change and bind the logical port to the
                  corresponding VTEP gateway chassis. Configuration of
                  binding the same VTEP logical switch to a different
                  OVN logical networks is not allowed and a warning will
                  be generated in the log.

              5.  Beside binding to the VTEP gateway chassis, the
                  <b>ovn-controller-vtep </b>will update the <i>tunnel_key</i> column
                  of the VTEP logical switch to the corresponding
                  <b>Datapath_Binding </b>table entry’s <i>tunnel_key</i> for the
                  bound OVN logical network.

              6.  Next, the <b>ovn-controller-vtep </b>will keep reacting to
                  the configuration change in the <b>Port_Binding </b>in the
                  <b>OVN_Northbound </b>database, and updating the
                  <b>Ucast_Macs_Remote </b>table in the <b>VTEP </b>database. This
                  allows the VTEP gateway to understand where to forward
                  the unicast traffic coming from the extended external
                  network.

              7.  Eventually, the VTEP gateway’s life cycle ends when
                  the administrator unregisters the VTEP gateway from
                  the <b>VTEP </b>database. The <b>ovn-controller-vtep </b>will
                  recognize the event and remove all related
                  configurations (<b>Chassis </b>table entry and port bindings)
                  in the <b>OVN_Southbound </b>database.

              8.  When the <b>ovn-controller-vtep </b>is terminated, all
                  related configurations in the <b>OVN_Southbound </b>database
                  and the <b>VTEP </b>database will be cleaned, including
                  <b>Chassis </b>table entries for all registered VTEP gateways
                  and their port bindings, and all <b>Ucast_Macs_Remote</b>
                  table entries and the <b>Logical_Switch </b>tunnel keys.

   <b>Native OVN services for external logical ports</b>
       To support OVN native services (like DHCP/IPv6 RA/DNS lookup) to
       the cloud resources which are external, OVN supports <b>external</b>
       logical ports.

       Below are some of the use cases where <b>external </b>ports can be used.

              •      VMs connected to SR-IOV nics - Traffic from these
                     VMs by passes the kernel stack and local
                     <b>ovn-controller </b>do not bind these ports and cannot
                     serve the native services.

              •      When CMS supports provisioning baremetal servers.

       OVN will provide the native services if CMS has done the below
       configuration in the <i>OVN Northbound Database</i>.

              •      A row is created in <b>Logical_Switch_Port</b>,
                     configuring the <b>addresses </b>column and setting the
                     <b>type </b>to <b>external</b>.

              •      <b>ha_chassis_group </b>column is configured.

              •      The HA chassis which belongs to the HA chassis
                     group has the <b>ovn-bridge-mappings </b>configured and
                     has proper L2 connectivity so that it can receive
                     the DHCP and other related request packets from
                     these external resources.

              •      The Logical_Switch of this port has a <b>localnet</b>
                     port.

              •      Native OVN services are enabled by configuring the
                     DHCP and other options like the way it is done for
                     the normal logical ports.

       It is recommended to use the same HA chassis group for all the
       external ports of a logical switch. Otherwise, the physical
       switch might see MAC flap issue when different chassis provide
       the native services. For example when supporting native DHCPv4
       service, DHCPv4 server mac (configured in <b>options:server_mac</b>
       column in table <b>DHCP_Options</b>) originating from different ports
       can cause MAC flap issue. The MAC of the logical router IP(s) can
       also flap if the same HA chassis group is not set for all the
       external ports of a logical switch.
</pre>